<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>üêï Doginal Dash</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { overflow: hidden; background: #0f0f1a; }
    body { display: flex; align-items: center; justify-content: center; min-height: 100vh; }
    canvas { display: block; }
    #mobile-controls { display: none; position: fixed; bottom: 20px; left: 0; right: 0; padding: 0 20px; justify-content: space-between; z-index: 100; }
    @media (pointer: coarse) { #mobile-controls { display: flex; } }
    .dpad { display: flex; gap: 10px; }
    .dpad button { width: 70px; height: 70px; border-radius: 15px; background: rgba(20,20,40,0.95); border: 3px solid rgba(255,255,255,0.5); color: #fff; font-size: 24px; }
    .dpad button:active { background: rgba(60,60,120,0.95); transform: scale(0.95); }
    .action-btns { display: flex; gap: 15px; }
    .action-btns button { width: 80px; height: 80px; border-radius: 50%; border: none; font-family: 'Press Start 2P', monospace; font-size: 14px; box-shadow: 0 6px 0 rgba(0,0,0,0.7); }
    .btn-b { background: #7c3aed; color: #fff; }
    .btn-a { background: #f59e0b; color: #000; }
    .action-btns button:active { transform: translateY(6px); box-shadow: none; }
    #powerups { display: none; position: fixed; right: 20px; top: 50%; transform: translateY(-50%); flex-direction: column; gap: 15px; z-index: 100; }
    @media (pointer: coarse) { #powerups { display: flex; } }
    .pup { width: 60px; height: 60px; border-radius: 12px; background: rgba(20,20,40,0.9); border: 3px solid #333; display: flex; align-items: center; justify-content: center; font-size: 28px; opacity: 0.4; }
    .pup.active { opacity: 1; border-color: #f59e0b; box-shadow: 0 0 20px rgba(245,158,11,0.6); }
  </style>
</head>
<body>
  <div id="mobile-controls">
    <div class="dpad">
      <button id="btn-left">‚óÄ</button>
      <button id="btn-right">‚ñ∂</button>
    </div>
    <div class="action-btns">
      <button class="btn-b" id="btn-b">B</button>
      <button class="btn-a" id="btn-a">A</button>
    </div>
  </div>
  <div id="powerups">
    <div class="pup" id="pup-jetpack">üéí</div>
    <div class="pup" id="pup-magnet">üß≤</div>
  </div>

<script type="module">
import kaboom from "https://unpkg.com/kaboom@3000.0.1/dist/kaboom.mjs";

const k = kaboom({
  canvas: document.createElement("canvas"),
  width: 1000,
  height: 650,
  background: [15, 10, 25],
  crisp: true,
});
document.body.appendChild(k.canvas);

// ============ GAME STATE ============
let score = 0, bones = 0, lives = 3, gameTime = 0;
let combo = 0, comboTimer = 0;
let highScore = parseInt(localStorage.getItem('doginalHighScore')) || 0;
let gameState = "title", currentLevel = 1, levelCompleteShown = false;
let hasJetpack = false, hasMagnet = false;
let jetpackActive = false, magnetActive = false;
let jetpackFuel = 0, powerupTimer = 0;

const TILE = 50, LEVEL_DURATION = 45;

// ============ THEMES ============
const themes = {
  forest: { sky: [30, 80, 30], ground: [80, 50, 20], platform: [120, 80, 40] },
  desert: { sky: [255, 180, 80], ground: [160, 120, 60], platform: [180, 130, 60] },
  ice: { sky: [100, 180, 255], ground: [150, 200, 220], platform: [80, 150, 200] },
  night: { sky: [15, 10, 35], ground: [50, 40, 70], platform: [70, 50, 100] }
};
let currentTheme = "forest";

// ============ DIFFICULTY - MUCH HARDER ============
function getDifficulty(level) {
  // Big gaps, narrow platforms, lots of enemies
  if (level === 1) return { name: "WARMUP", gapMin: 4, gapMax: 6, platW: 3, enemy: 0.1 };
  if (level === 2) return { name: "GETTING REAL", gapMin: 5, gapMax: 8, platW: 2.5, enemy: 0.2 };
  if (level === 3) return { name: "SERIOUS", gapMin: 6, gapMax: 10, platW: 2, enemy: 0.25 };
  if (level === 4) return { name: "COMMITTED", gapMin: 7, gapMax: 11, platW: 1.8, enemy: 0.3 };
  if (level === 5) return { name: "STRESSED", gapMin: 8, gapMax: 12, platW: 1.5, enemy: 0.35 };
  if (level === 6) return { name: "HARD", gapMin: 9, gapMax: 14, platW: 1.3, enemy: 0.4 };
  if (level === 7) return { name: "EXTREME", gapMin: 10, gapMax: 16, platW: 1, enemy: 0.45 };
  return { name: "BRUTAL", gapMin: 11, gapMax: 18, platW: 0.8, enemy: 0.5 };
}

// ============ DRAW PIXEL DOG ============
function drawDog(x, y, w, h, flip) {
  const s = w / 16;
  const colors = { B: [139,94,60], D: [92,58,30], L: [245,230,208], N: [30,20,10], T: [224,112,80] };
  const draw = (cx, cy, c) => c && drawRect({ pos: vec2(x + cx*s, y + cy*s), width: s, height: s, color: colors[c] });
  const grid = [
    [0,0,0,"D","D","D","D","D","D","D",0,0,0,0,0,0],["D","D",0,"B","B","B","B","B","B","B","D","D",0,0,0,0],["D","B","B","B","L","B","B","L","B","B","B","B","D",0,0,0],["D","B","B","N","B","B","N","B","B","B","B","B","D",0,0,0],["D","B","B","B","B","B","B","B","B","B","B","B","D",0,0,0],["D","D","B","B","B","T","B","B","B","B","D","D",0,0,0,0],[0,"D","B","B","B","B","B","B","B","B","D",0,0,0,0,0],[0,"D","B","B","B","B","B","B","B","B","B","D",0,0,0,0],["D","D","D","B","B","B","B","B","B","B","B","B","D",0,0],["B","B","B","B","B","B","B","B","B","B","B","B","B","D",0],["B","B","B","B","B","B","B","B","B","B","B","B","B","B","D"],["D","B","B","B","B","B","B","B","B","B","B","B","B","D",0],[0,"D","D","B","B","D","D","B","B","D","B","B","D",0,0,0],[0,0,0,"D","D",0,0,"D","D",0,"D","D",0,0,0,0],[0,0,0,"D","D",0,0,"D","D",0,"D","D",0,0,0,0],[0,0,0,"D",0,0,0,"D",0,0,"D",0,0,0,0,0]
  ];
  grid.forEach((row, ry) => row.forEach((c, cx) => {
    const dx = flip ? 15 - cx : cx;
    draw(dx, ry, c);
  }));
}

// ============ PLAYER ============
let player = null;
let playerImg = null;

function spawnPlayer() {
  player = add([
    rect(48, 48),
    area({ shape: new Rect(vec2(0, 0), 40, 44) }),
    body(),
    pos(60, 450),
    "player",
    { speed: 300, jumpForce: 580, jumpsLeft: 2, invincible: 0 }
  ]);
}

// ============ LEVEL GENERATION ============
let worldWidth = 0;

function generateLevel() {
  destroyAll("platform", "coin", "mystery", "enemy", "moving");
  
  const diff = getDifficulty(currentLevel);
  const worldLen = 50 + currentLevel * 20;
  
  let lastX = 0;
  let currentY = height() - TILE;
  
  // Safe start
  add([ rect(200, TILE), area(), pos(0, currentY), color(themes[currentTheme].ground), "platform", "ground" ]);
  lastX = 200;
  
  for (let i = 0; i < worldLen; i++) {
    // HUGE gaps - 4-18 tiles!
    const gapTiles = diff.gapMin + Math.floor(Math.random() * (diff.gapMax - diff.gapMin + 1));
    const gap = gapTiles * TILE;
    lastX += gap;
    
    // Narrow platforms
    const platW = Math.max(TILE, diff.platW * TILE);
    
    // Height varies A LOT
    currentY = Math.max(100, Math.min(height() - TILE - 80, currentY + (Math.random() - 0.4) * TILE * 3));
    
    // Moving platforms (30% chance after level 2)
    let isMoving = false, moveAxis = "x", moveSpeed = 100, moveRange = 100;
    if (currentLevel >= 2 && Math.random() < 0.3) {
      isMoving = true;
      if (currentLevel >= 4) {
        moveAxis = Math.random() < 0.4 ? "y" : "x";
        moveSpeed = 120 + currentLevel * 20;
        moveRange = 100 + currentLevel * 15;
      } else {
        moveSpeed = 80;
        moveRange = 80;
      }
    }
    
    const plat = add([
      rect(platW, TILE),
      area(),
      pos(lastX, currentY),
      color(themes[currentTheme].platform),
      "platform",
      { 
        width: platW, isMoving, moveAxis, moveSpeed, moveRange, 
        origX: lastX, origY: currentY, moveDir: 1, standTime: 0 
      }
    ]);
    
    // Enemies
    if (diff.enemy > 0 && Math.random() < diff.enemy && platW > 70) {
      add([
        rect(28, 24),
        area({ shape: new Rect(vec2(0, 0), 28, 24) }),
        pos(lastX + platW/2 - 14, currentY - 28),
        color(160, 60, 20),
        "enemy",
        { startX: lastX + platW/2 - 14, range: platW/2 - 20, dir: Math.random() < 0.5 ? 1 : -1, speed: 70 + currentLevel * 15 }
      ]);
    }
    
    // Coins (less frequent - work for them!)
    if (Math.random() < 0.35) {
      add([ circle(10), area(), pos(lastX + platW/2, currentY - 45), color(255,215,0), "coin" ]);
    }
    
    // Mystery boxes (rare)
    if (Math.random() < 0.04) {
      add([ rect(35, 35), area(), pos(lastX + platW/2 - 17, currentY - TILE - 35), color(200,150,50), "mystery", { opened: false } ]);
    }
    
    lastX += platW + 30;
  }
  
  // Finish
  add([ rect(180, TILE), area(), pos(lastX, height() - TILE), color(255,255,255), "platform", "finish" ]);
  worldWidth = lastX + 180;
}

// ============ SCREENS ============
function showTitle() {
  destroyAll();
  gameState = "title";
  add([ rect(width(), height()), color(15,10,25) ]);
  add([ text("üêï DOGINAL DASH", { size: 48 }), pos(width()/2, 100), anchor("center"), color(245,200,66) ]);
  add([ text("Test your skills!", { size: 20 }), pos(width()/2, 170), anchor("center"), color(150,150,150) ]);
  
  const btn = add([ rect(240, 60), pos(width()/2, 280), anchor("center"), color(245,200,66), area(), "startbtn" ]);
  add([ text("START", { size: 20 }), pos(width()/2, 280), anchor("center"), color(0,0,0) ]);
  add([ text(`üèÜ HIGH SCORE: ${highScore}`, { size: 16 }), pos(width()/2, 380), anchor("center"), color(255,215,0) ]);
  
  onClick("startbtn", () => startGame());
}

function showGameOver() {
  gameState = "gameover";
  const isNew = score > highScore;
  if (isNew) { highScore = score; localStorage.setItem('doginalHighScore', highScore); }
  
  add([ rect(width(), height()), color(0,0,0), opacity(0.9) ]);
  add([ text("GAME OVER", { size: 42 }), pos(width()/2, 120), anchor("center"), color(255,80,80) ]);
  if (isNew) add([ text("üèÜ NEW HIGH SCORE!", { size: 20 }), pos(width()/2, 190), anchor("center"), color(255,215,0) ]);
  add([ text(`Score: ${score}`, { size: 20 }), pos(width()/2, 250), anchor("center") ]);
  add([ text(`Time: ${Math.floor(gameTime/60)}:${Math.floor(gameTime%60).toString().padStart(2,'0')}`, { size: 16 }), pos(width()/2, 300), anchor("center"), color(150,150,150) ]);
  add([ text(`Bones: ${bones}`, { size: 16 }), pos(width()/2, 340), anchor("center"), color(150,150,150) ]);
  
  const retryBtn = add([ rect(160, 55), pos(width()/2 - 90, 420), color(245,200,66), area(), "retrybtn" ]);
  add([ text("RETRY", { size: 16 }), pos(width()/2 - 90, 420), anchor("center"), color(0,0,0) ]);
  const menuBtn = add([ rect(160, 55), pos(width()/2 + 90, 420), color(60,60,80), area(), "menubtn" ]);
  add([ text("MENU", { size: 16 }), pos(width()/2 + 90, 420), anchor("center"), color(255,255,255) ]);
  
  onClick("retrybtn", () => startGame());
  onClick("menubtn", () => showTitle());
}

function showLevelComplete() {
  gameState = "levelcomplete";
  levelCompleteShown = true;
  const bonus = currentLevel * 400;
  score += bonus;
  
  add([ rect(width(), height()), color(0,0,0), opacity(0.9) ]);
  add([ text("LEVEL COMPLETE!", { size: 36 }), pos(width()/2, 120), anchor("center"), color(100,255,100) ]);
  add([ text(`Level ${currentLevel}`, { size: 18 }), pos(width()/2, 190), anchor("center"), color(150,150,150) ]);
  add([ text(`+${bonus} BONUS`, { size: 26 }), pos(width()/2, 250), anchor("center"), color(255,215,0) ]);
  add([ text(`Total: ${score}`, { size: 18 }), pos(width()/2, 310), anchor("center") ]);
  
  const contBtn = add([ rect(220, 55), pos(width()/2, 420), color(245,200,66), area(), "contbtn" ]);
  add([ text("CONTINUE ‚Üí", { size: 16 }), pos(width()/2, 420), anchor("center"), color(0,0,0) ]);
  
  onClick("contbtn", () => { currentLevel++; gameState = "playing"; generateLevel(); spawnPlayer(); levelCompleteShown = false; });
}

function startGame() {
  gameState = "playing";
  score = 0; bones = 0; lives = 3; gameTime = 0; combo = 0;
  currentLevel = 1; levelCompleteShown = false;
  hasJetpack = false; hasMagnet = false; jetpackActive = false; magnetActive = false; jetpackFuel = 0;
  
  const keys = Object.keys(themes);
  currentTheme = keys[Math.floor(Math.random() * keys.length)];
  
  generateLevel();
  spawnPlayer();
  camPos(width()/2, height()/2);
  updatePowerups();
}

function updatePowerups() {
  const jp = document.getElementById('pup-jetpack');
  const mg = document.getElementById('pup-magnet');
  jp.className = 'pup' + (hasJetpack ? ' active' : '');
  mg.className = 'pup' + (hasMagnet ? ' active' : '');
  jp.style.display = hasJetpack ? 'flex' : 'none';
  mg.style.display = hasMagnet ? 'flex' : 'none';
}

// ============ CONTROLS ============
const keysDown = new Set();
const setKey = (k, v) => v ? keysDown.add(k) : keysDown.delete(k);

['left','right','space','up','w','a','d'].forEach(k => {
  document.getElementById('btn-left')?.addEventListener('touchstart', e => { e.preventDefault(); setKey('left', true); });
  document.getElementById('btn-left')?.addEventListener('touchend', e => { e.preventDefault(); setKey('left', false); });
  document.getElementById('btn-right')?.addEventListener('touchstart', e => { e.preventDefault(); setKey('right', true); });
  document.getElementById('btn-right')?.addEventListener('touchend', e => { e.preventDefault(); setKey('right', false); });
  document.getElementById('btn-a')?.addEventListener('touchstart', e => { e.preventDefault(); setKey('space', true); });
  document.getElementById('btn-a')?.addEventListener('touchend', e => { e.preventDefault(); setKey('space', false); });
});

document.getElementById('pup-jetpack')?.addEventListener('click', () => {
  if (hasJetpack && !jetpackActive && gameState === 'playing') {
    jetpackActive = true;
    jetpackFuel = 4;
  }
});

document.getElementById('pup-magnet')?.addEventListener('click', () => {
  if (hasMagnet && !magnetActive && gameState === 'playing') {
    magnetActive = true;
    powerupTimer = 8;
  }
});

// ============ GAME LOOP ============
onUpdate(() => {
  if (gameState !== "playing") return;
  
  gameTime += dt();
  
  // Level complete every 45s
  if (gameTime % LEVEL_DURATION < 0.1 && !levelCompleteShown && currentLevel > 1) {
    showLevelComplete();
    return;
  }
  
  if (!player) return;
  
  if (player.invincible > 0) player.invincible -= dt();
  
  // Powerup timers
  if (jetpackActive) {
    jetpackFuel -= dt();
    if (jetpackFuel <= 0) jetpackActive = false;
  }
  if (magnetActive) {
    powerupTimer -= dt();
    if (powerupTimer <= 0) magnetActive = false;
  }
  
  // Movement
  let spd = player.speed, jump = player.jumpForce, grav = 2000;
  if (jetpackActive && keysDown.has("space")) { player.vy = -450; grav = 500; }
  if (keysDown.has("left") || keysDown.has("a")) { player.move(-spd, 0); player.flipX = true; }
  if (keysDown.has("right") || keysDown.has("d")) { player.move(spd, 0); player.flipX = false; }
  
  // Jump
  if ((isKeyPressed("space") || keysDown.has("space")) && player.jumpsLeft > 0) {
    player.jump(jump);
    player.jumpsLeft--;
    keysDown.delete("space");
  }
  if (player.isGrounded()) player.jumpsLeft = 2;
  
  // Fall death
  if (player.pos.y > height() + 150) {
    lives--;
    if (lives <= 0) showGameOver();
    else { player.pos = vec2(60, 400); player.invincible = 3; }
  }
  
  // Camera
  camPos(Math.max(width()/2, player.pos.x), height()/2);
  
  // Combo
  if (comboTimer > 0) { comboTimer -= dt(); if (comboTimer <= 0) combo = 0; }
  
  // Score
  score += Math.floor(dt() * 3);
  
  // ============ PLATFORMS ============
  get("platform").forEach(p => {
    // Moving platforms
    if (p.isMoving) {
      if (p.moveAxis === "x") {
        p.pos.x += p.moveSpeed * dt() * p.moveDir;
        if (p.pos.x > p.origX + p.moveRange || p.pos.x < p.origX - p.moveRange) p.moveDir *= -1;
      } else {
        p.pos.y += p.moveSpeed * dt() * p.moveDir;
        if (p.pos.y > p.origY + p.moveRange || p.pos.y < p.origY - p.moveRange) p.moveDir *= -1;
      }
    }
  });
  
  // ============ ENEMIES ============
  get("enemy").forEach(e => {
    e.move(e.dir * e.speed, 0);
    if (e.pos.x < e.startX - e.range || e.pos.x > e.startX + e.range) e.dir *= -1;
    
    if (player.isColliding(e) && player.invincible <= 0) {
      if (player.vy > 0 && player.pos.y < e.pos.y - 5) {
        destroy(e);
        player.jump(jump * 0.65);
        combo++; comboTimer = 2;
        score += 100 * Math.min(combo, 10);
      } else {
        lives--;
        if (lives <= 0) showGameOver();
        else { player.invincible = 3; player.pos = vec2(60, 400); }
      }
    }
  });
  
  // ============ COINS ============
  get("coin").forEach(c => {
    // Magnet pull
    if (magnetActive) {
      const dx = player.pos.x - c.pos.x;
      const dy = player.pos.y - c.pos.y;
      const dist = Math.sqrt(dx*dx + dy*dy);
      if (dist < 350) {
        c.pos.x += (dx/dist) * 400 * dt();
        c.pos.y += (dy/dist) * 400 * dt();
      }
    }
    if (player.isColliding(c)) {
      destroy(c);
      bones++; combo++; comboTimer = 2;
      score += 50 * Math.min(combo, 10);
    }
  });
  
  // ============ MYSTERY BOXES ============
  get("mystery").forEach(m => {
    if (!m.opened && player.isColliding(m)) {
      m.opened = true;
      m.height = 12;
      const r = Math.random();
      if (r < 0.35) { hasJetpack = true; updatePowerups(); }
      else if (r < 0.6) { hasMagnet = true; updatePowerups(); }
      else { score += 150; bones++; }
    }
  });
});

// ============ RENDER ============
onDraw(() => {
  if (gameState === "title") return;
  
  const theme = themes[currentTheme];
  drawRect({ pos: camPos().sub(width()/2, height()/2), width: width(), height: height(), color: theme.sky });
  
  // Finish line
  get("finish").forEach(f => {
    for (let r = 0; r < f.height/12; r++) {
      for (let c = 0; c < f.width/12; c++) {
        drawRect({ pos: f.pos.add(c*12, r*12), width: 12, height: 12, color: (r+c)%2===0 ? [0,0,0] : [255,255,255] });
      }
    }
  });
  
  // Player
  if (player && player.invincible <= 0) {
    if (jetpackActive) {
      drawCircle({ pos: player.pos.add(24, 44), radius: 10 + Math.random() * 8, color: [255,120,0] });
    }
    if (playerImg) {
      drawTexture(playerImg, { pos: player.pos, width: 60, height: 60, flipX: player.flipX });
    } else {
      drawDog(player.pos.x, player.pos.y, 48, 48, player.flipX);
    }
  }
  
  // Magnet ring
  if (magnetActive) {
    drawCircle({ pos: player.pos.add(24, 24), radius: 150, color: [100,200,255], opacity: 0.1 });
  }
  
  // ============ HUD ============
  drawText({ text: `‚≠ê ${score}`, pos: vec2(20, 20), size: 20 });
  drawText({ text: `ü¶¥ ${bones}`, pos: vec2(20, 50), size: 20 });
  drawText({ text: `LV ${currentLevel}`, pos: vec2(20, 80), size: 14, color: [120,120,120] });
  drawText({ text: getDifficulty(currentLevel).name, pos: vec2(90, 80), size: 10, color: [100,100,100] });
  
  const mins = Math.floor(gameTime/60), secs = Math.floor(gameTime%60);
  drawText({ text: `‚è± ${mins}:${secs.toString().padStart(2,'0')}`, pos: vec2(width()-130, 20), size: 20 });
  
  let livesStr = "";
  for (let i = 0; i < 3; i++) livesStr += i < lives ? "üêæ" : "üíÄ";
  drawText({ text: livesStr, pos: vec2(width()-110, 50), size: 20 });
  
  if (combo > 1) drawText({ text: `üî• x${combo}`, pos: vec2(20, 115), size: 22, color: [255,150,0] });
  
  // Jetpack bar
  if (jetpackActive) {
    drawRect({ pos: vec2(width()/2 - 60, 20), width: 120, height: 10, color: [40,40,40] });
    drawRect({ pos: vec2(width()/2 - 60, 20), width: 120 * (jetpackFuel/4), height: 10, color: [255,150,0] });
  }
  
  // Magnet bar
  if (magnetActive) {
    drawRect({ pos: vec2(width()/2 - 60, 38), width: 120, height: 8, color: [40,40,40] });
    drawRect({ pos: vec2(width()/2 - 60, 38), width: 120 * (powerupTimer/8), height: 8, color: [100,200,255] });
  }
});

showTitle();
</script>
</body>
</html>
