<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>üêï Doginal Dash</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Outfit:wght@400;600;800&display=swap');
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { overflow: hidden; background: #0a0a1a; }
    body { display: flex; align-items: center; justify-content: center; min-height: 100vh; }
    canvas { display: block; max-width: 100%; max-height: 100vh; }
    #mobile-controls { display: none; position: fixed; bottom: 20px; left: 0; right: 0; padding: 0 20px; justify-content: space-between; z-index: 100; }
    @media (pointer: coarse) { #mobile-controls { display: flex; } }
    .dpad { display: flex; gap: 8px; }
    .dpad button { width: 60px; height: 60px; border-radius: 12px; background: rgba(40,40,60,0.9); border: 2px solid rgba(255,255,255,0.3); color: #fff; font-size: 24px; }
    .dpad button:active { background: rgba(80,80,120,0.9); }
    .action-btns { display: flex; gap: 12px; }
    .action-btns button { width: 70px; height: 70px; border-radius: 50%; border: none; font-family: 'Press Start 2P', monospace; font-size: 14px; cursor: pointer; box-shadow: 0 4px 0 rgba(0,0,0,0.5); }
    .btn-b { background: #8b2252; color: #fff; }
    .btn-a { background: #f5c842; color: #000; }
    .action-btns button:active { transform: translateY(4px); box-shadow: none; }
  </style>
</head>
<body>
  <div id="mobile-controls">
    <div class="dpad">
      <button id="btn-left">‚Üê</button>
      <button id="btn-right">‚Üí</button>
    </div>
    <div class="action-btns">
      <button class="btn-b" id="btn-b">B</button>
      <button class="btn-a" id="btn-a">A</button>
    </div>
  </div>

<script type="module">
import kaboom from "https://unpkg.com/kaboom@3000.0.1/dist/kaboom.mjs";

const k = kaboom({
  canvas: document.createElement("canvas"),
  width: 800,
  height: 500,
  background: [26, 10, 46],
  crisp: true,
  scale: 1,
});

document.body.appendChild(k.canvas);

// Game state
let score = 0;
let bones = 0;
let lives = 3;
let gameTime = 0;
let combo = 0;
let comboTimer = 0;
let activePowerUp = null;
let powerUpTimer = 0;
let highScore = parseInt(localStorage.getItem('doginalHighScore')) || 0;
let gameState = "title";
let currentLevel = 1;
let levelCompleteShown = false;

// Constants
const TILE_SIZE = 50;
const LEVEL_DURATION = 45; // seconds per level

// Themes
const themes = {
  vegas: { sky: [26, 10, 46], platform: [139, 34, 82], platformTop: [255, 105, 180], accent: [255, 0, 255], coin: [255, 215, 0], enemy: [255, 68, 68] },
  miami: { sky: [255, 105, 180], platform: [0, 206, 209], platformTop: [127, 255, 212], accent: [0, 255, 0], coin: [255, 107, 107], enemy: [255, 107, 107] },
  nyc: { sky: [10, 10, 46], platform: [255, 215, 0], platformTop: [255, 255, 0], accent: [255, 255, 0], coin: [255, 215, 0], enemy: [255, 68, 68] }
};

let currentTheme = "vegas";

// Difficulty per level
function getDifficulty(level) {
  if (level === 1) return { name: "TUTORIAL", maxGap: 1, enemySpeed: 0, platformWidth: 3, moving: false, spinning: false, crumbling: false, enemyDensity: 0, powerupFreq: 0 };
  if (level === 2) return { name: "WARMING UP", maxGap: 2, enemySpeed: 60, platformWidth: 2.5, moving: "slow", spinning: false, crumbling: false, enemyDensity: 0.1, powerupFreq: 4 };
  if (level === 3) return { name: "GETTING REAL", maxGap: 2, enemySpeed: 80, platformWidth: 2, moving: "slow", spinning: false, crumbling: false, enemyDensity: 0.2, powerupFreq: 5 };
  if (level === 4) return { name: "COMMITTED", maxGap: 3, enemySpeed: 100, platformWidth: 1.8, moving: "medium", spinning: true, crumbling: false, enemyDensity: 0.25, powerupFreq: 6 };
  if (level === 5) return { name: "STRESSFUL", maxGap: 3, enemySpeed: 120, platformWidth: 1.5, moving: "medium", spinning: true, crumbling: false, enemyDensity: 0.3, powerupFreq: 7 };
  if (level === 6) return { name: "HARD", maxGap: 4, enemySpeed: 140, platformWidth: 1.3, moving: "fast", spinning: true, crumbling: true, enemyDensity: 0.35, powerupFreq: 8 };
  if (level === 7) return { name: "VERY HARD", maxGap: 5, enemySpeed: 160, platformWidth: 1.1, moving: "fast", spinning: true, crumbling: true, enemyDensity: 0.4, powerupFreq: 10 };
  if (level === 8) return { name: "BRUTAL", maxGap: 6, enemySpeed: 180, platformWidth: 0.9, moving: "chaos", spinning: true, crumbling: true, enemyDensity: 0.5, powerupFreq: 12 };
  return { name: "ENDLESS", maxGap: 7, enemySpeed: 200, platformWidth: 0.7, moving: "chaos", spinning: true, crumbling: true, enemyDensity: 0.6, powerupFreq: 15 };
}

// Load sprites (procedural)
function createPlayerSprite() {
  const p = add([
    rect(40, 40),
    area(),
    body(),
    pos(100, 300),
    "player",
    {
      speed: 200,
      jumpForce: 450,
      jumpsLeft: 2,
      invincible: 0,
      hasShield: false,
      glowColor: null,
    }
  ]);
  return p;
}

// Generate level
let platforms = [];
let enemies = [];
let coins = [];
let powerups = [];
let worldWidth = 0;

function generateLevel() {
  // Clear existing
  destroyAll("platform");
  destroyAll("enemy");
  destroyAll("coin");
  destroyAll("powerup");
  destroyAll("moving");
  destroyAll("spinning");
  destroyAll("crumbling");
  
  platforms = [];
  enemies = [];
  coins = [];
  powerups = [];
  
  const diff = getDifficulty(currentLevel);
  const worldLength = 80 + currentLevel * 20; // Longer per level
  
  // Starting ground
  let lastX = 0;
  const startGround = add([
    rect(400, TILE_SIZE),
    area(),
    pos(0, height() - TILE_SIZE),
    color(themes[currentTheme].platform),
    "platform",
    "ground",
  ]);
  platforms.push({ x: 0, y: height() - TILE_SIZE, w: 400 });
  lastX = 400;
  
  let currentY = height() - TILE_SIZE;
  let platformId = 0;
  
  for (let i = 0; i < worldLength; i++) {
    // Gap chance increases with level
    const gapChance = Math.min(0.15 + (currentLevel * 0.05), 0.4);
    
    if (Math.random() < gapChance && i > 5) {
      const gapSize = Math.floor(Math.random() * diff.maxGap) + 1;
      lastX += gapSize * TILE_SIZE;
    }
    
    // Platform width
    const platWidth = Math.max(TILE_SIZE, diff.platformWidth * TILE_SIZE);
    
    // Height variation
    const heightChange = (Math.random() - 0.5) * 80;
    currentY = Math.max(100, Math.min(height() - TILE_SIZE - 50, currentY + heightChange));
    
    // Platform type
    let platformType = "platform";
    let isSpinning = false;
    let isMoving = false;
    let isCrumbling = false;
    let movingInfo = null;
    
    // Spinning platforms (level 4+)
    if (diff.spinning && Math.random() < 0.1) {
      platformType = "spinning";
      isSpinning = true;
    }
    // Moving platforms
    else if (diff.moving && Math.random() < 0.12) {
      platformType = "moving";
      isMoving = true;
      if (diff.moving === "slow") movingInfo = { speed: 40, range: 80, axis: "x" };
      else if (diff.moving === "medium") movingInfo = { speed: 80, range: 120, axis: Math.random() < 0.5 ? "x" : "y" };
      else if (diff.moving === "fast" || diff.moving === "chaos") movingInfo = { speed: 120, range: 150, axis: Math.random() < 0.3 ? "y" : "x" };
    }
    // Crumbling platforms (level 6+)
    else if (diff.crumbling && Math.random() < 0.08) {
      platformType = "crumbling";
      isCrumbling = true;
    }
    
    const p = add([
      rect(platWidth, TILE_SIZE),
      area(),
      pos(lastX, currentY),
      color(themes[currentTheme].platform),
      platformType,
      {
        originalX: lastX,
        originalY: currentY,
        platformId: platformId++,
        isMoving,
        isSpinning,
        isCrumbling,
        movingInfo,
        moveDir: 1,
        spinAngle: 0,
        crumbleTimer: 0,
        crumbling: false,
        stoodOn: false,
      },
      "platform",
    ]);
    
    platforms.push({ x: lastX, y: currentY, w: platWidth, obj: p });
    
    // Add enemies
    if (diff.enemyDensity > 0 && Math.random() < diff.enemyDensity && platWidth > 60) {
      const e = add([
        rect(30, 24),
        area({ shape: new Rect(vec2(0, 0), 30, 24) }),
        pos(lastX + platWidth / 2 - 15, currentY - 28),
        color(themes[currentTheme].enemy),
        "enemy",
        {
          originalX: lastX + platWidth / 2 - 15,
          speed: diff.enemySpeed,
          range: platWidth / 2 - 20,
          direction: 1,
        },
      ]);
      enemies.push({ obj: e, platform: p });
    }
    
    // Add coins
    if (Math.random() < 0.6) {
      for (let c = 0; c < 3; c++) {
        add([
          rect(16, 16),
          area(),
          pos(lastX + 20 + c * 35, currentY - 50 - Math.random() * 30),
          color(themes[currentTheme].coin),
          "coin",
          { collected: false },
        ]);
      }
    }
    
    // Add power-ups
    if (diff.powerupFreq > 0 && Math.random() < 1 / diff.powerupFreq) {
      const types = ["speed", "shield", "float", "fire"];
      const type = types[Math.floor(Math.random() * types.length)];
      add([
        rect(24, 24),
        area(),
        pos(lastX + platWidth / 2 - 12, currentY - TILE_SIZE),
        color(type === "speed" ? [255, 255, 0] : type === "shield" ? [0, 255, 255] : type === "float" ? [255, 0, 255] : [255, 100, 0]),
        "powerup",
        { type, collected: false },
      ]);
    }
    
    lastX += platWidth + 30;
  }
  
  // Finish platform
  add([
    rect(300, TILE_SIZE),
    area(),
    pos(lastX, height() - TILE_SIZE),
    color(themes[currentTheme].platform),
    "platform",
    "finish",
  ]);
  
  worldWidth = lastX + 300;
}

// Player
let player = null;

function spawnPlayer() {
  if (player) destroy(player);
  
  player = createPlayerSprite();
  player.pos = vec2(100, 300);
  player.jumpsLeft = 2;
  player.invincible = 0;
  player.hasShield = false;
}

// UI Layers
function drawHUD() {
  // Score
  drawText({
    text: `‚≠ê ${score}`,
    pos: vec2(20, 20),
    size: 16,
    font: "monospace",
  });
  
  // Bones
  drawText({
    text: `ü¶¥ ${bones}`,
    pos: vec2(20, 45),
    size: 16,
    font: "monospace",
  });
  
  // Level
  drawText({
    text: `LV ${currentLevel}`,
    pos: vec2(20, 70),
    size: 12,
    font: "monospace",
    color: [100, 100, 100],
  });
  
  // Level name
  const diff = getDifficulty(currentLevel);
  drawText({
    text: diff.name,
    pos: vec2(70, 70),
    size: 10,
    font: "monospace",
    color: [150, 150, 150],
  });
  
  // Timer
  const mins = Math.floor(gameTime / 60);
  const secs = Math.floor(gameTime % 60);
  drawText({
    text: `‚è± ${mins}:${secs.toString().padStart(2, "0")}`,
    pos: vec2(width() - 120, 20),
    size: 16,
    font: "monospace",
  });
  
  // Lives
  let livesText = "";
  for (let i = 0; i < 3; i++) livesText += i < lives ? "üêæ" : "üíÄ";
  drawText({
    text: livesText,
    pos: vec2(width() - 100, 45),
    size: 16,
    font: "monospace",
  });
  
  // Combo
  if (combo > 1) {
    drawText({
      text: `üî• x${combo}`,
      pos: vec2(20, 95),
      size: 18,
      font: "monospace",
      color: [255, 100, 0],
    });
  }
  
  // Power-up bar
  if (activePowerUp && powerUpTimer > 0) {
    const barWidth = 100;
    const pct = powerUpTimer / 600;
    drawRect({ pos: vec2(width() / 2 - barWidth / 2, 20), width: barWidth, height: 8, color: [50, 50, 50] });
    const barColor = activePowerUp === "speed" ? [255, 255, 0] : activePowerUp === "shield" ? [0, 255, 255] : activePowerUp === "float" ? [255, 0, 255] : [255, 100, 0];
    drawRect({ pos: vec2(width() / 2 - barWidth / 2, 20), width: barWidth * pct, height: 8, color: barColor });
  }
}

function showTitleScreen() {
  destroyAll();
  gameState = "title";
  
  add([
    text("üêï DOGINAL DASH", { size: 32 }),
    pos(width() / 2, 100),
    anchor("center"),
    color(245, 200, 66),
  ]);
  
  add([
    text("How far can you run?", { size: 16 }),
    pos(width() / 2, 150),
    anchor("center"),
    color(150, 150, 150),
  ]);
  
  // Start button
  const startBtn = add([
    rect(200, 50),
    pos(width() / 2, 220),
    anchor("center"),
    color(245, 200, 66),
    area(),
    "startbtn",
  ]);
  add([
    text("START", { size: 16 }),
    pos(width() / 2, 220),
    anchor("center"),
    color(0, 0, 0),
  ]);
  
  // High score
  add([
    text(`üèÜ HIGH SCORE: ${highScore}`, { size: 14 }),
    pos(width() / 2, 300),
    anchor("center"),
    color(255, 215, 0),
  ]);
  
  onClick("startbtn", () => startGame());
}

function showGameOver() {
  gameState = "gameover";
  
  const isNewHigh = score > highScore;
  if (isNewHigh) {
    highScore = score;
    localStorage.setItem("doginalHighScore", highScore);
  }
  
  add([
    rect(width(), height()),
    pos(0, 0),
    color(0, 0, 0),
    opacity(0.8),
  ]);
  
  add([
    text("GAME OVER", { size: 28 }),
    pos(width() / 2, 120),
    anchor("center"),
    color(255, 100, 100),
  ]);
  
  if (isNewHigh) {
    add([
      text("üèÜ NEW HIGH SCORE!", { size: 16 }),
      pos(width() / 2, 170),
      anchor("center"),
      color(255, 215, 0),
    ]);
  }
  
  add([
    text(`Score: ${score}`, { size: 16 }),
    pos(width() / 2, 220),
    anchor("center"),
  ]);
  
  add([
    text(`Time: ${Math.floor(gameTime / 60)}:${Math.floor(gameTime % 60).toString().padStart(2, "0")}`, { size: 14 }),
    pos(width() / 2, 255),
    anchor("center"),
    color(150, 150, 150),
  ]);
  
  add([
    text(`Bones: ${bones}`, { size: 14 }),
    pos(width() / 2, 285),
    anchor("center"),
    color(150, 150, 150),
  ]);
  
  // Retry button
  const retryBtn = add([
    rect(150, 45),
    pos(width() / 2 - 80, 340),
    color(245, 200, 66),
    area(),
    "retrybtn",
  ]);
  add([
    text("RETRY", { size: 14 }),
    pos(width() / 2 - 80, 340),
    anchor("center"),
    color(0, 0, 0),
  ]);
  
  // Menu button
  const menuBtn = add([
    rect(150, 45),
    pos(width() / 2 + 80, 340),
    color(80, 80, 80),
    area(),
    "menubtn",
  ]);
  add([
    text("MENU", { size: 14 }),
    pos(width() / 2 + 80, 340),
    anchor("center"),
    color(255, 255, 255),
  ]);
  
  onClick("retrybtn", () => startGame());
  onClick("menubtn", () => showTitleScreen());
}

function showLevelComplete() {
  gameState = "levelcomplete";
  levelCompleteShown = true;
  
  const bonus = currentLevel * 500;
  score += bonus;
  
  add([
    rect(width(), height()),
    pos(0, 0),
    color(0, 0, 0),
    opacity(0.85),
  ]);
  
  add([
    text("LEVEL COMPLETE!", { size: 24 }),
    pos(width() / 2, 120),
    anchor("center"),
    color(100, 255, 100),
  ]);
  
  add([
    text(`Level ${currentLevel}`, { size: 16 }),
    pos(width() / 2, 170),
    anchor("center"),
    color(150, 150, 150),
  ]);
  
  add([
    text(`+${bonus} BONUS`, { size: 18 }),
    pos(width() / 2, 220),
    anchor("center"),
    color(255, 215, 0),
  ]);
  
  add([
    text(`Total: ${score}`, { size: 16 }),
    pos(width() / 2, 260),
    anchor("center"),
  ]);
  
  // Continue button
  const contBtn = add([
    rect(180, 45),
    pos(width() / 2, 330),
    anchor("center"),
    color(245, 200, 66),
    area(),
    "continuebtn",
  ]);
  add([
    text("CONTINUE ‚Üí", { size: 14 }),
    pos(width() / 2, 330),
    anchor("center"),
    color(0, 0, 0),
  ]);
  
  onClick("continuebtn", () => {
    currentLevel++;
    gameState = "playing";
    generateLevel();
    spawnPlayer();
    levelCompleteShown = false;
  });
}

function startGame() {
  gameState = "playing";
  score = 0;
  bones = 0;
  lives = 3;
  gameTime = 0;
  combo = 0;
  activePowerUp = null;
  powerUpTimer = 0;
  currentLevel = 1;
  levelCompleteShown = false;
  
  // Pick random theme
  const themeKeys = Object.keys(themes);
  currentTheme = themeKeys[Math.floor(Math.random() * themeKeys.length)];
  
  generateLevel();
  spawnPlayer();
  camPos(width() / 2, height() / 2);
}

// Main game loop
onUpdate(() => {
  if (gameState !== "playing") return;
  
  gameTime += dt();
  
  // Check level complete
  const timeInLevel = gameTime % LEVEL_DURATION;
  if (timeInLevel < 0.1 && !levelCompleteShown && currentLevel > 1) {
    showLevelComplete();
    return;
  }
  
  // Update player
  if (!player) return;
  
  // Invincibility
  if (player.invincible > 0) player.invincible -= dt();
  
  // Power-up timer
  if (powerUpTimer > 0) {
    powerUpTimer -= dt();
    if (powerUpTimer <= 0) activePowerUp = null;
  }
  
  // Speed/power effects
  let moveSpeed = player.speed;
  let jumpForce = player.jumpForce;
  let gravityVal = 1600;
  
  if (activePowerUp === "speed") moveSpeed = 350;
  if (activePowerUp === "float") gravityVal = 500;
  
  // Movement
  if (isKeyDown("left") || isKeyDown("a") || downKeys.has("left")) {
    player.move(-moveSpeed, 0);
    player.flipX = true;
  }
  if (isKeyDown("right") || isKeyDown("d") || downKeys.has("right")) {
    player.move(moveSpeed, 0);
    player.flipX = false;
  }
  
  // Jumping
  if ((isKeyPressed("space") || isKeyPressed("up") || isKeyPressed("w") || downKeys.has("space")) && player.jumpsLeft > 0) {
    player.jump(jumpForce);
    player.jumpsLeft--;
    downKeys.delete("space");
  }
  
  // Double jump
  if ((isKeyPressed("space") || isKeyPressed("up") || isKeyPressed("w")) && player.jumpsLeft === 0 && player.isGrounded()) {
    // Can't double jump without air jump ability
  }
  
  // Ground check
  if (player.isGrounded()) {
    player.jumpsLeft = 2;
  }
  
  // Fall death
  if (player.pos.y > height() + 100) {
    if (player.hasShield) {
      player.hasShield = false;
      player.pos = vec2(100, 200);
      player.invincible = 2;
    } else {
      lives--;
      if (lives <= 0) {
        showGameOver();
      } else {
        player.pos = vec2(100, 200);
        player.invincible = 3;
      }
    }
  }
  
  // Camera follow
  camPos(Math.max(width() / 2, player.pos.x), height() / 2);
  
  // Combo decay
  if (comboTimer > 0) {
    comboTimer -= dt();
    if (comboTimer <= 0) combo = 0;
  }
  
  // Update platforms
  get("platform").forEach(p => {
    // Spinning platforms
    if (p.isSpinning) {
      p.spinAngle += dt() * 2;
      p.angle = Math.sin(p.spinAngle) * 15;
    }
    
    // Moving platforms
    if (p.isMoving && p.movingInfo) {
      if (p.movingInfo.axis === "x") {
        p.pos.x += p.movingInfo.speed * dt() * p.moveDir;
        if (p.pos.x > p.originalX + p.movingInfo.range || p.pos.x < p.originalX - p.movingInfo.range) {
          p.moveDir *= -1;
        }
      } else {
        p.pos.y += p.movingInfo.speed * dt() * p.moveDir;
        if (p.pos.y > p.originalY + p.movingInfo.range || p.pos.y < p.originalY - p.movingInfo.range) {
          p.moveDir *= -1;
        }
      }
    }
    
    // Crumbling platforms
    if (p.isCrumbling && p.crumbleTimer > 0) {
      p.crumbleTimer -= dt();
      if (p.crumbleTimer <= 0) {
        p.crumbling = true;
        destroy(p);
      }
    }
  });
  
  // Enemy movement
  get("enemy").forEach(e => {
    e.move(e.speed * e.direction, 0);
    const platform = enemies.find(en => en.obj === e)?.platform;
    if (platform) {
      const range = platform?.width / 2 - 20 || 50;
      if (e.pos.x > (platform?.pos.x || 0) + range || e.pos.x < (platform?.pos.x || 0) - range) {
        e.direction *= -1;
      }
    }
    
    // Player collision
    if (player.isColliding(e) && player.invincible <= 0) {
      // Check if stomped
      if (player.pos.y < e.pos.y - 10 && player.vy > 0) {
        destroy(e);
        player.jump(jumpForce * 0.8);
        combo++;
        comboTimer = 2;
        score += 150 * Math.min(combo, 10);
      } else if (!player.hasShield) {
        lives--;
        if (lives <= 0) {
          showGameOver();
        } else {
          player.invincible = 3;
          player.pos = vec2(100, 200);
        }
      } else {
        player.hasShield = false;
        player.invincible = 2;
      }
    }
  });
  
  // Coin collection
  get("coin").forEach(c => {
    if (!c.collected && player.isColliding(c)) {
      c.collected = true;
      destroy(c);
      bones++;
      combo++;
      comboTimer = 2;
      score += 100 * Math.min(combo, 10);
    }
  });
  
  // Power-up collection
  get("powerup").forEach(p => {
    if (!p.collected && player.isColliding(p)) {
      p.collected = true;
      destroy(p);
      activePowerUp = p.type;
      powerUpTimer = 10;
      if (p.type === "shield") player.hasShield = true;
      combo++;
      comboTimer = 2;
      score += 50;
    }
  });
  
  // Platform standing (for crumbling)
  get("platform").forEach(p => {
    if (p.isCrumbling && !p.crumbling && player.isColliding(p)) {
      if (player.isGrounded()) {
        p.crumbleTimer = 1; // 1 second to jump off
      }
    }
  });
  
  // Scoring for distance
  score += Math.floor(dt() * 10);
});

// Rendering
onDraw(() => {
  if (gameState === "title") return;
  
  // Draw background gradient
  const theme = themes[currentTheme];
  drawRect({
    pos: camPos().sub(width() / 2, height() / 2),
    width: width(),
    height: height(),
    color: theme.sky,
  });
  
  // Draw platforms
  get("platform").forEach(p => {
    // Top highlight
    drawRect({
      pos: p.pos,
      width: p.width,
      height: 6,
      color: theme.platformTop,
    });
    
    // Spinning indicator
    if (p.isSpinning) {
      drawCircle({
        pos: p.pos.add(p.width / 2, p.height / 2),
        radius: 5,
        color: [255, 255, 0],
      });
    }
    
    // Moving indicator
    if (p.isMoving) {
      drawCircle({
        pos: p.pos.add(p.width / 2, p.height + 10),
        radius: 4,
        color: [200, 200, 200],
      });
    }
  });
  
  // Draw finish line
  get("finish").forEach(f => {
    for (let row = 0; row < f.height / 12; row++) {
      for (let col = 0; col < f.width / 12; col++) {
        drawRect({
          pos: f.pos.add(col * 12, row * 12),
          width: 12,
          height: 12,
          color: (row + col) % 2 === 0 ? [0, 0, 0] : [255, 255, 255],
        });
      }
    }
  });
  
  drawHUD();
  
  // Screen flash effect
  if (player && player.invincible > 0 && Math.floor(player.invincible * 10) % 2 === 0) {
    // Flicker effect handled by not drawing
  }
});

// Mobile controls - use Kaboom's key handling
const downKeys = new Set();

function handleMobileKey(key, add) {
  if (add) {
    downKeys.add(key);
    kaboom.global().keyDownMap[key] = true;
  } else {
    downKeys.delete(key);
    kaboom.global().keyDownMap[key] = false;
  }
}

document.getElementById("btn-left").addEventListener("touchstart", (e) => { e.preventDefault(); handleMobileKey("left", true); });
document.getElementById("btn-left").addEventListener("touchend", (e) => { e.preventDefault(); handleMobileKey("left", false); });
document.getElementById("btn-left").addEventListener("mousedown", () => handleMobileKey("left", true));
document.getElementById("btn-left").addEventListener("mouseup", () => handleMobileKey("left", false));

document.getElementById("btn-right").addEventListener("touchstart", (e) => { e.preventDefault(); handleMobileKey("right", true); });
document.getElementById("btn-right").addEventListener("touchend", (e) => { e.preventDefault(); handleMobileKey("right", false); });
document.getElementById("btn-right").addEventListener("mousedown", () => handleMobileKey("right", true));
document.getElementById("btn-right").addEventListener("mouseup", () => handleMobileKey("right", false));

document.getElementById("btn-a").addEventListener("touchstart", (e) => { e.preventDefault(); handleMobileKey("space", true); });
document.getElementById("btn-a").addEventListener("touchend", (e) => { e.preventDefault(); handleMobileKey("space", false); });
document.getElementById("btn-a").addEventListener("mousedown", () => handleMobileKey("space", true));
document.getElementById("btn-a").addEventListener("mouseup", () => handleMobileKey("space", false));

// Initialize
showTitleScreen();
</script>
</body>
</html>
