<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>üêï Doginal Dash</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Outfit:wght@400;600;800&display=swap');
    :root { --primary: #f5c842; --bg-dark: #0a0a1a; }
    * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    html, body { overflow: hidden; touch-action: none; background: var(--bg-dark); }
    body { display: flex; align-items: center; justify-content: center; min-height: 100vh; background: #0a0a1a; padding: 10px; }
    #gameContainer { position: relative; max-width: 100vw; max-height: 100vh; }
    #gameCanvas { display: block; width: 100%; max-width: 800px; aspect-ratio: 16/10; image-rendering: pixelated; border-radius: 8px; background: #1a1a2e; }
    #mobileControls { display: none; position: fixed; bottom: 20px; left: 0; right: 0; padding: 0 20px; justify-content: space-between; align-items: flex-end; pointer-events: none; z-index: 100; }
    @media (pointer: coarse) { #mobileControls { display: flex; } }
    .dpad-mobile { display: flex; gap: 8px; pointer-events: auto; }
    .dpad-btn-mobile { width: 60px; height: 60px; border-radius: 12px; background: rgba(40,40,60,0.8); border: 2px solid rgba(255,255,255,0.2); color: #fff; font-size: 24px; display: flex; align-items: center; justify-content: center; user-select: none; -webkit-user-select: none; touch-action: manipulation; }
    .dpad-btn-mobile:active { background: rgba(60,60,80,0.9); transform: scale(0.95); }
    .action-btns-mobile { display: flex; gap: 12px; pointer-events: auto; }
    .btn-mobile { width: 70px; height: 70px; border-radius: 50%; border: none; font-family: 'Press Start 2P', monospace; font-size: 14px; cursor: pointer; box-shadow: 0 4px 0 rgba(0,0,0,0.5); }
    .btn-b-mobile { background: #8b2252; color: #fff; }
    .btn-a-mobile { background: #f5c842; color: #000; }
    .btn-mobile:active { transform: translateY(4px); box-shadow: none; }
    #titleScreen, #gameOverScreen, #levelCompleteScreen { position: absolute; inset: 0; background: rgba(10,10,26,0.95); display: none; flex-direction: column; align-items: center; justify-content: center; border-radius: 8px; padding: 20px; text-align: center; }
    #titleScreen.active, #gameOverScreen.active, #levelCompleteScreen.active { display: flex; }
    .screen-title { font-family: 'Press Start 2P', monospace; font-size: clamp(1rem, 4vw, 2rem); color: var(--primary); margin-bottom: 20px; text-shadow: 0 0 20px var(--primary); }
    .screen-subtitle { font-family: 'Outfit', sans-serif; font-size: clamp(0.8rem, 2vw, 1rem); color: #aaa; margin-bottom: 30px; }
    .screen-btn { background: var(--primary); color: #000; font-family: 'Press Start 2P', monospace; font-size: clamp(0.6rem, 2vw, 0.8rem); padding: 15px 30px; border: none; border-radius: 8px; cursor: pointer; margin: 8px; box-shadow: 0 4px 0 #b8941f; transition: transform 0.1s; }
    .screen-btn:active { transform: translateY(4px); box-shadow: none; }
    .screen-btn.secondary { background: #333; color: #fff; box-shadow: 0 4px 0 #111; }
    .high-score-display { font-family: 'Press Start 2P', monospace; font-size: clamp(0.5rem, 1.5vw, 0.7rem); color: #ffd700; margin-top: 20px; }
    .stat-row { font-family: 'Outfit', sans-serif; font-size: clamp(0.8rem, 2vw, 1rem); color: #fff; margin: 8px 0; }
    .stat-label { color: #888; }
    .new-high-score { font-family: 'Press Start 2P', monospace; font-size: clamp(0.7rem, 2vw, 1rem); color: #ffd700; animation: pulse 0.5s ease-in-out infinite alternate; }
    @keyframes pulse { from { transform: scale(1); } to { transform: scale(1.1); } }
    .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.9); display: none; align-items: center; justify-content: center; z-index: 1000; }
    .modal-overlay.active { display: flex; }
    .modal { background: #12122a; border-radius: 12px; padding: 1.5rem; max-width: 90vw; width: 320px; border: 2px solid var(--primary); position: relative; }
    .modal h2 { font-family: 'Press Start 2P', monospace; font-size: 0.7rem; color: var(--primary); margin-bottom: 1rem; text-align: center; }
    .drop-zone { border: 2px dashed #444; border-radius: 8px; padding: 1.5rem; text-align: center; cursor: pointer; }
    .drop-zone-text { color: #aaa; font-size: 0.85rem; }
    #pfp-input { display: none; }
    .validation-msg { margin-top: 1rem; padding: 0.5rem; border-radius: 6px; font-size: 0.75rem; display: none; }
    .validation-msg.success { display: block; background: rgba(74, 222, 128, 0.1); border: 1px solid #4ade80; color: #4ade80; }
    .validation-msg.error { display: block; background: rgba(248, 113, 113, 0.1); border: 1px solid #f87171; color: #f87171; }
    .btn-primary { background: var(--primary); color: #000; font-weight: 600; padding: 0.6rem 1.5rem; border: none; border-radius: 6px; cursor: pointer; font-size: 0.9rem; margin-top: 1rem; width: 100%; }
    .btn-primary:disabled { opacity: 0.5; }
    .close-modal { position: absolute; top: 10px; right: 10px; background: none; border: none; color: #666; font-size: 1.2rem; cursor: pointer; }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas" width="800" height="500"></canvas>
    <div id="titleScreen" class="active">
      <div class="screen-title">üêï DOGINAL DASH</div>
      <div class="screen-subtitle">How far can you run?</div>
      <button class="screen-btn" onclick="startGame()">START</button>
      <button class="screen-btn secondary" onclick="openUploadModal()">UPLOAD PFP</button>
      <div class="high-score-display">üèÜ HIGH SCORE: <span id="titleHighScore">0</span></div>
    </div>
    <div id="gameOverScreen">
      <div class="screen-title" style="color: #f87171;">GAME OVER</div>
      <div class="new-high-score" id="newHighScoreText" style="display:none;">üèÜ NEW HIGH SCORE!</div>
      <div class="stat-row"><span class="stat-label">SCORE:</span> <span id="finalScore">0</span></div>
      <div class="stat-row"><span class="stat-label">TIME:</span> <span id="finalTime">0:00</span></div>
      <div class="stat-row"><span class="stat-label">BONES:</span> <span id="finalCoins">0</span></div>
      <div style="margin-top: 20px;">
        <button class="screen-btn secondary" onclick="showTitleScreen()">MENU</button>
        <button class="screen-btn" onclick="restartGame()">RETRY</button>
      </div>
    </div>
    <div id="levelCompleteScreen">
      <div class="screen-title" style="color: #4ade80;">TIME BONUS!</div>
      <div class="stat-row"><span class="stat-label">TIME REACHED:</span> <span id="levelTime">0:00</span></div>
      <div class="stat-row"><span class="stat-label">BONUS POINTS:</span> <span id="levelBonus">0</span></div>
      <div class="stat-row"><span class="stat-label">TOTAL SCORE:</span> <span id="levelTotal">0</span></div>
      <button class="screen-btn" onclick="continueGame()">NEXT ‚Üí</button>
    </div>
    <div class="modal-overlay" id="upload-modal">
      <div class="modal">
        <button class="close-modal" onclick="closeUploadModal()">√ó</button>
        <h2>üêï UPLOAD PFP</h2>
        <div class="drop-zone" id="drop-zone"><div class="drop-zone-text">Tap to choose image</div></div>
        <input type="file" id="pfp-input" accept="image/*">
        <div class="validation-msg" id="validation-msg"></div>
        <button class="btn-primary" id="use-pfp-btn" disabled onclick="applyPfp()">USE PFP</button>
      </div>
    </div>
    <div id="mobileControls">
      <div class="dpad-mobile">
        <button class="dpad-btn-mobile" id="btnLeft">‚Üê</button>
        <button class="dpad-btn-mobile" id="btnRight">‚Üí</button>
      </div>
      <div class="action-btns-mobile">
        <button class="btn-mobile btn-b-mobile" id="btnB">B</button>
        <button class="btn-mobile btn-a-mobile" id="btnA">A</button>
      </div>
    </div>
  </div>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;

let gameState = 'title';
let score = 0, bones = 0, lives = 3;
let gameTime = 0;
let highScore = parseInt(localStorage.getItem('doginalHighScore')) || 0;
let newHighScore = false;
let endlessMode = false;
let worldWidth = 0;

let player = { x: 100, y: 300, w: 48, h: 48, vx: 0, vy: 0, onGround: false, jumpsLeft: 2, facing: 1, bobTime: 0, dead: false, invincible: 0, hasShield: false, glowColor: null };

const TILE = 50;
const GRAVITY = 0.65;
const JUMP_FORCE = -14;
const SPEED = 5;
let currentSpeed = SPEED;
let currentGravity = GRAVITY;

let keys = {};
let animFrame = 0;
let cameraX = 0;

let combo = 0, comboTimer = 0;
let comboPopups = [];

let activePowerUp = null;
let powerUpTimer = 0;
let powerUpDuration = 600;
let powerUpCooldown = 0;

let particles = [];

let screenFlash = 0;
let screenShake = { x: 0, y: 0, time: 0 };

let platforms = [];
let enemies = [];
let coins = [];
let powerups = [];
let fireballs = [];

let playerImg = null;
let pendingPfp = null;
const TEST_PFP_HASH = '3772';

const THEMES = ['vegas', 'miami', 'nyc'];
let currentTheme = 0;
let themeTransition = 0;

const themeData = {
  vegas: { skyTop: '#1a0a2e', skyMid: '#2d1b4e', skyBot: '#4a1a5e', ground: '#5a1a1a', groundPattern: '#8b0000', platform: '#8b2252', platformTop: '#ff69b4', accent: '#ff00ff', coin: '#ffd700', enemy: '#ff4444' },
  miami: { skyTop: '#ff69b4', skyMid: '#ff8c42', skyBot: '#ffc0cb', ground: '#ffb6c1', groundPattern: '#ffffff', platform: '#00ced1', platformTop: '#7fffd4', accent: '#00ff00', coin: '#ff6b6b', enemy: '#ff6b6b' },
  nyc: { skyTop: '#0a0a2e', skyMid: '#1a1a3e', skyBot: '#2a2a4e', ground: '#4a4a5a', groundPattern: '#ffd700', platform: '#ffd700', platformTop: '#ffff00', accent: '#ffff00', coin: '#ffd700', enemy: '#ff4444' }
};

function getTheme() { return themeData[THEMES[currentTheme]]; }
function randomTheme() { themeTransition = 60; currentTheme = Math.floor(Math.random() * THEMES.length); }

// Level milestones: every 30-60 seconds
const LEVEL_DURATION = 45; // seconds per level

function getLevel() {
  return Math.floor(gameTime / LEVEL_DURATION) + 1;
}

function getDifficulty() {
  const level = getLevel();
  if (level === 1) return { level: 'tutorial', name: 'TUTORIAL', maxGap: 1, enemySpeed: 0, platformWidth: 3, movingPlatforms: false, powerupFreq: 2, enemyDensity: 0 };
  if (level === 2) return { level: 'warmup', name: 'WARMING UP', maxGap: 2, enemySpeed: 1, platformWidth: 2.5, movingPlatforms: 'slow', powerupFreq: 3, enemyDensity: 0.15 };
  if (level === 3) return { level: 'gettingReal', name: 'GETTING REAL', maxGap: 3, enemySpeed: 1.5, platformWidth: 2, movingPlatforms: 'medium', powerupFreq: 4, enemyDensity: 0.25 };
  if (level === 4) return { level: 'committed', name: 'COMMITTED', maxGap: 3, enemySpeed: 2, platformWidth: 1.8, movingPlatforms: 'medium', powerupFreq: 5, enemyDensity: 0.35 };
  if (level === 5) return { level: 'stressful', name: 'STRESSFUL', maxGap: 4, enemySpeed: 2.5, platformWidth: 1.5, movingPlatforms: 'fast', powerupFreq: 6, enemyDensity: 0.4 };
  if (level === 6) return { level: 'hard', name: 'HARD', maxGap: 5, enemySpeed: 3, platformWidth: 1.2, movingPlatforms: 'vertical', powerupFreq: 8, enemyDensity: 0.5 };
  if (level === 7) return { level: 'veryHard', name: 'VERY HARD', maxGap: 6, enemySpeed: 3.5, platformWidth: 1, movingPlatforms: 'opposing', powerupFreq: 10, enemyDensity: 0.6 };
  if (level === 8) return { level: 'brutal', name: 'BRUTAL', maxGap: 7, enemySpeed: 4, platformWidth: 0.7, movingPlatforms: 'chaos', powerupFreq: 12, enemyDensity: 0.8 };
  return { level: 'endless', name: 'ENDLESS', maxGap: 7, enemySpeed: 4, platformWidth: 0.5, movingPlatforms: 'chaos', powerupFreq: 15, enemyDensity: 1 };
}

function checkLevelComplete() {
  const level = getLevel();
  const timeInLevel = gameTime % LEVEL_DURATION;
  const nextLevelTime = (level) * LEVEL_DURATION;
  
  // Level complete when we reach the next threshold
  if (timeInLevel < 1 && level > 1 && !levelCompleteTriggered) {
    levelCompleteTriggered = true;
    const bonus = level * 500;
    score += bonus;
    
    document.getElementById('levelTime').textContent = formatTime(gameTime);
    document.getElementById('levelBonus').textContent = bonus;
    document.getElementById('levelTotal').textContent = score;
    document.getElementById('levelCompleteScreen').classList.add('active');
    gameState = 'levelComplete';
  }
}

let levelCompleteTriggered = false;

function generateWorld() {
  platforms = []; enemies = []; coins = []; powerups = []; fireballs = [];
  const diff = getDifficulty();
  const worldLength = 200;
  
  platforms.push({ x: 0, y: H - TILE, w: 8 * TILE, h: TILE, type: 'ground' });
  let lastPlatformEnd = 8 * TILE;
  let currentY = H - TILE;
  let movingPlatformId = 0;
  
  for (let i = 8; i < worldLength; i++) {
    const gapChance = Math.min(0.3 + (gameTime / 120), 0.6);
    if (Math.random() < gapChance && i > 10) {
      const gapSize = Math.floor(Math.random() * diff.maxGap) + 1;
      const gapWidth = gapSize * TILE;
      if (gameTime > 180 && Math.random() < 0.2) {
        for (let g = 0; g < 3; g++) { const gSize = Math.floor(Math.random() * diff.maxGap) + 1; i += gSize; gapWidth += gSize * TILE; }
      }
      lastPlatformEnd += gapWidth;
      i += gapSize - 1;
    }
    
    const heightChange = (Math.random() - 0.5) * TILE * 2;
    currentY = Math.max(TILE * 2, Math.min(H - TILE, currentY + heightChange));
    const platWidth = Math.max(TILE, diff.platformWidth * TILE);
    
    let pType = 'platform';
    let moving = null;
    if (diff.movingPlatforms && Math.random() < 0.15) {
      pType = 'moving';
      if (diff.movingPlatforms === 'slow') moving = { type: 'horizontal', range: 80, speed: 1, dir: 1 };
      else if (diff.movingPlatforms === 'medium') moving = { type: 'horizontal', range: 120, speed: 2, dir: 1 };
      else if (diff.movingPlatforms === 'fast') moving = { type: 'horizontal', range: 150, speed: 3, dir: 1 };
      else if (diff.movingPlatforms === 'vertical') moving = { type: Math.random() < 0.5 ? 'horizontal' : 'vertical', range: 100, speed: 2, dir: 1 };
      else if (diff.movingPlatforms === 'opposing') moving = { type: 'horizontal', range: 130, speed: 2.5, dir: Math.random() < 0.5 ? 1 : -1 };
      else if (diff.movingPlatforms === 'chaos') moving = { type: Math.random() < 0.3 ? 'vertical' : 'horizontal', range: 120 + Math.random() * 80, speed: 3 + Math.random() * 2, dir: 1 };
    }
    
    if (gameTime > 420 && Math.random() < 0.1) pType = 'crumbling';
    
    const platform = { x: lastPlatformEnd, y: currentY, w: platWidth, h: TILE, type: pType, moving: moving, movingId: movingPlatformId++, startX: lastPlatformEnd, startY: currentY, originalX: lastPlatformEnd, originalY: currentY, crumbleTimer: 0, crumbling: false };
    platforms.push(platform);
    lastPlatformEnd += platWidth + 20;
    
    if (diff.enemyDensity > 0 && Math.random() < diff.enemyDensity) {
      enemies.push({ x: platform.x + platform.w / 2, y: platform.y - 32, w: 40, h: 32, vx: diff.enemySpeed * (Math.random() < 0.5 ? 1 : -1), startX: platform.x + platform.w / 2, range: platform.w / 2 - 20, alive: true, platform: platform });
    }
    
    if (Math.random() < 0.7) {
      const coinSpacing = gameTime < 60 ? 60 : (gameTime < 180 ? 40 : 25);
      for (let c = 0; c < 3; c++) { coins.push({ x: platform.x + 20 + c * coinSpacing, y: platform.y - 50 - Math.random() * 30, w: 24, h: 24, collected: false, baseY: platform.y - 50 - Math.random() * 30 }); }
    }
    
    if (Math.random() < 1 / diff.powerupFreq) {
      const types = ['speed', 'shield', 'float', 'fire'];
      powerups.push({ x: platform.x + platform.w / 2 - 16, y: platform.y - TILE, w: 32, h: 32, type: types[Math.floor(Math.random() * types.length)], collected: false, baseY: platform.y - TILE });
    }
  }
  
  platforms.push({ x: lastPlatformEnd, y: H - TILE, w: 10 * TILE, h: TILE, type: 'finish' });
  worldWidth = lastPlatformEnd + 10 * TILE;
}

function drawBackground() {
  const t = getTheme();
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  if (themeTransition > 0) { const prevT = themeData[THEMES[(currentTheme + 2) % 3]]; const blend = themeTransition / 60; grad.addColorStop(0, blendTween(prevT.skyTop, t.skyTop, blend)); grad.addColorStop(0.6, blendTween(prevT.skyMid, t.skyMid, blend)); grad.addColorStop(1, blendTween(prevT.skyBot, t.skyBot, blend)); themeTransition--; }
  else { grad.addColorStop(0, t.skyTop); grad.addColorStop(0.6, t.skyMid); grad.addColorStop(1, t.skyBot); }
  ctx.fillStyle = grad; ctx.fillRect(0, 0, W, H);
  ctx.fillStyle = t.groundPattern; ctx.globalAlpha = 0.3;
  for (let i = 0; i < 15; i++) { const bx = ((i * 120 - cameraX * 0.1) % (W + 200)) - 100; const bh = 80 + (i * 37) % 100; ctx.fillRect(bx, H - TILE - bh, 60, bh); }
  ctx.fillStyle = t.platform; ctx.globalAlpha = 0.5;
  for (let i = 0; i < 12; i++) { const bx = ((i * 150 - cameraX * 0.3) % (W + 200)) - 100; const bh = 60 + (i * 53) % 80; ctx.fillRect(bx, H - TILE - bh, 50, bh); }
  ctx.globalAlpha = 1;
  ctx.fillStyle = '#ffffff88';
  for (let i = 0; i < 30; i++) { const sx = ((i * 73 + 200) % (W * 2) - cameraX * 0.2) % W; const sy = (i * 37 + 50) % (H * 0.6); ctx.fillRect(sx, sy, 2, 2); }
}

function blendTween(c1, c2, t) { const r1 = parseInt(c1.slice(1,3), 16), g1 = parseInt(c1.slice(3,5), 16), b1 = parseInt(c1.slice(5,7), 16); const r2 = parseInt(c2.slice(1,3), 16), g2 = parseInt(c2.slice(3,5), 16), b2 = parseInt(c2.slice(5,7), 16); return `rgb(${Math.round(r1 + (r2-r1)*(1-t))},${Math.round(g1 + (g2-g1)*(1-t))},${Math.round(b1 + (b2-b1)*(1-t))})`; }

function drawPlatform(p) {
  const t = getTheme();
  const drawX = p.x - cameraX;
  if (p.type === 'finish') {
    ctx.fillStyle = '#fff'; ctx.fillRect(drawX, p.y, p.w, TILE);
    for (let row = 0; row < TILE/12; row++) { for (let col = 0; col < p.w/12; col++) { ctx.fillStyle = (row+col)%2===0 ? '#000' : '#fff'; ctx.fillRect(drawX + col*12, p.y + row*12, 12, 12); } }
    ctx.fillStyle = '#888'; ctx.fillRect(drawX + p.w - 20, p.y - 80, 6, 80);
    ctx.fillStyle = '#f00'; ctx.beginPath(); ctx.moveTo(drawX + p.w - 14, p.y - 80); ctx.lineTo(drawX + p.w + 30, p.y - 65); ctx.lineTo(drawX + p.w - 14, p.y - 50); ctx.fill();
    return;
  }
  if (p.crumbling) ctx.fillStyle = `rgb(255,${100+Math.sin(animFrame*0.5)*100},100)`;
  else if (p.type === 'crumbling' && p.crumbleTimer > 0) ctx.fillStyle = `rgb(255,${Math.min(255,200+p.crumbleTimer)},${Math.min(255,200+p.crumbleTimer)})`;
  else ctx.fillStyle = t.platform;
  ctx.fillRect(drawX, p.y, p.w, TILE);
  if (p.type !== 'crumbling' || p.crumbleTimer <= 0) { ctx.fillStyle = t.platformTop; ctx.fillRect(drawX, p.y, p.w, 6); }
  if (p.moving) { ctx.fillStyle = 'rgba(0,0,0,0.3)'; ctx.fillRect(drawX + 4, p.y + TILE + 10, p.w - 8, 6); }
}

function drawEnemy(e) {
  if (!e.alive) return;
  const drawX = e.x - cameraX;
  const t = getTheme();
  ctx.fillStyle = t.enemy; ctx.fillRect(drawX, e.y, e.w, e.h);
  ctx.fillStyle = '#fff'; ctx.fillRect(drawX + 6, e.y - 6, 10, 10); ctx.fillRect(drawX + e.w - 16, e.y - 6, 10, 10);
  const lookDir = player.x > e.x ? 1 : 0;
  ctx.fillStyle = '#000'; ctx.fillRect(drawX + 8 + lookDir*4, e.y - 4, 4, 4); ctx.fillRect(drawX + e.w - 14 + lookDir*4, e.y - 4, 4, 4);
}

function drawCoin(c) {
  if (c.collected) return;
  const t = getTheme();
  const float = Math.sin(animFrame * 0.08 + c.x * 0.01) * 4;
  const drawX = c.x - cameraX;
  const s = c.w / 8;
  for (let row = 1; row <= 6; row++) { for (let col = 1; col <= 6; col++) { const dist = Math.sqrt((col-3.5)**2 + (row-3.5)**2); if (dist < 3.2) { ctx.fillStyle = (col + row + Math.floor(animFrame * 0.1)) % 2 === 0 ? t.coin : '#ffe888'; ctx.fillRect(drawX + col*s, c.y + float + row*s, s, s); } } }
}

function drawPowerup(p) {
  if (p.collected) return;
  const colors = { speed: '#ffff00', shield: '#00ffff', float: '#ff00ff', fire: '#ff6600' };
  const float = Math.sin(animFrame * 0.1 + p.x * 0.01) * 5;
  const drawX = p.x - cameraX;
  ctx.shadowBlur = 20; ctx.shadowColor = colors[p.type];
  ctx.fillStyle = colors[p.type]; ctx.beginPath(); ctx.arc(drawX + 16, p.y + float + 16, 14, 0, Math.PI * 2); ctx.fill();
  ctx.shadowBlur = 0; ctx.fillStyle = '#000'; ctx.font = 'bold 14px sans-serif'; ctx.textAlign = 'center';
  const icons = { speed: '‚ö°', shield: 'üõ°Ô∏è', float: 'üéà', fire: 'üî•' };
  ctx.fillText(icons[p.type], drawX + 16, p.y + float + 22);
}

function drawFireball(f) {
  const drawX = f.x - cameraX;
  ctx.fillStyle = '#ff6600'; ctx.beginPath(); ctx.arc(drawX, f.y, 10, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#ffff00'; ctx.beginPath(); ctx.arc(drawX, f.y, 6, 0, Math.PI * 2); ctx.fill();
}

function drawDefaultDog(x, y, w, h, facing, bobOffset) {
  const scale = w / 16;
  const px = (col, row, color) => { ctx.fillStyle = color; ctx.fillRect(x + col * scale, y + row * scale + bobOffset, scale, scale); };
  const B = '#8B5E3C', D = '#5C3A1E', Wc = '#F5E6D0', N = '#1a0a00', T = '#e07050', _ = null;
  const grid = [
    [_,_,_,D,D,D,D,D,D,D,D,_,_,_,_,_],[_,_,D,B,B,B,B,B,B,B,D,D,_,_,_,_],[_,D,B,B,Wc,B,B,Wc,B,B,B,B,D,_,_,_],[_,D,B,B,N,B,B,N,B,B,B,B,D,_,_,_],[_,D,B,B,B,B,B,B,B,B,B,B,D,_,_,_],[_,D,D,B,B,B,T,B,B,B,D,D,_,_,_,_],[_,_,D,B,B,B,B,B,B,B,D,_,_,_,_,_],[_,_,D,B,B,B,B,B,B,B,B,D,_,_,_,_],[D,D,D,B,B,B,B,B,B,B,B,B,D,_,_,_],[B,B,B,B,B,B,B,B,B,B,B,B,B,D,_,_],[B,B,B,B,B,B,B,B,B,B,B,B,B,B,D,_],[D,B,B,B,B,B,B,B,B,B,B,B,B,D,_,_],[_,D,D,B,B,D,D,B,B,D,B,B,D,_,_,_],[_,_,_,D,D,_,_,D,D,_,D,D,_,_,_,_],[_,_,_,D,D,_,_,D,D,_,D,D,_,_,_,_],[_,_,_,D,_,_,_,D,_,_,D,_,_,_,_,_],
  ];
  grid.forEach((row, ry) => row.forEach((c, cx) => { if (!c) return; const dx = facing > 0 ? cx : 15 - cx; px(dx, ry, c); }));
}

function drawPlayer() {
  if (player.dead) return;
  const drawX = player.x - cameraX;
  const bob = Math.sin(player.bobTime) * 2;
  if (player.invincible > 0 && Math.floor(player.invincible / 4) % 2 === 0) return;
  if (player.glowColor) { ctx.shadowBlur = 25; ctx.shadowColor = player.glowColor; }
  if (player.hasShield) { ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 4; ctx.beginPath(); ctx.arc(drawX + player.w/2, player.y + player.h/2 + bob, player.w * 0.7, 0, Math.PI * 2); ctx.stroke(); }
  if (activePowerUp === 'fire') { ctx.fillStyle = 'rgba(255,100,0,0.6)'; ctx.beginPath(); ctx.arc(drawX + player.w + (player.facing>0?10:-10), player.y + player.h/2 + bob, 12 + Math.sin(animFrame*0.3)*4, 0, Math.PI*2); ctx.fill(); }
  if (playerImg) { ctx.save(); ctx.imageSmoothingEnabled = false; if (player.facing < 0) { ctx.translate(drawX + player.w, player.y + bob); ctx.scale(-1, 1); ctx.drawImage(playerImg, 0, 0, player.w, player.h); } else { ctx.drawImage(playerImg, drawX, player.y + bob, player.w, player.h); } ctx.restore(); }
  else { drawDefaultDog(drawX, player.y, player.w, player.h, player.facing, bob); }
  ctx.shadowBlur = 0;
  if (!player.onGround) { ctx.fillStyle = 'rgba(0,0,0,0.3)'; ctx.fillRect(drawX + 6, H - TILE - 4, player.w - 12, 6); }
  if (powerUpTimer > 0) { const colors = { speed: '#ffff00', shield: '#00ffff', float: '#ff00ff', fire: '#ff6600' }; ctx.fillStyle = '#333'; ctx.fillRect(drawX, player.y - 15, player.w, 6); ctx.fillStyle = colors[activePowerUp]; ctx.fillRect(drawX, player.y - 15, player.w * (powerUpTimer / powerUpDuration), 6); }
}

function drawHUD() {
  const t = getTheme();
  const level = getLevel();
  ctx.font = '14px "Press Start 2P", monospace';
  ctx.textAlign = 'left';
  ctx.fillStyle = t.accent;
  ctx.fillText('‚≠ê ' + score, 15, 30);
  ctx.fillText('ü¶¥ ' + bones, 15, 55);
  ctx.fillStyle = '#888';
  ctx.font = '10px "Press Start 2P", monospace';
  ctx.fillText('LV ' + level, 15, 75);
  if (combo > 1) { ctx.fillStyle = '#ff6600'; ctx.font = 'bold 16px "Press Start 2P", monospace'; ctx.fillText('üî• x' + combo, 15, 100); }
  ctx.textAlign = 'right';
  ctx.fillStyle = t.accent;
  ctx.font = '14px "Press Start 2P", monospace';
  ctx.fillText('‚è± ' + formatTime(gameTime), W - 15, 30);
  let livesText = '';
  for (let i = 0; i < 3; i++) { livesText += (i < lives) ? 'üêæ' : 'üíÄ'; }
  ctx.fillText(livesText, W - 15, 55);

  // Combo popups
  comboPopups.forEach(p => {
    ctx.fillStyle = 'rgba(255, 200, 0, ' + (p.life / 60) + ')';
    ctx.font = 'bold 14px "Press Start 2P", monospace';
    ctx.textAlign = 'center';
    ctx.fillText(p.text, p.x - cameraX, p.y);
  });
  
  // Screen flash
  if (screenFlash > 0) { ctx.fillStyle = screenFlashColor + Math.floor(screenFlash * 12).toString(16).padStart(2,'0'); ctx.fillRect(0, 0, W, H); screenFlash--; }
}

function addCombo(points) {
  combo++;
  comboTimer = 120;
  const mult = Math.min(combo, 10);
  score += points * mult;
  comboPopups.push({ x: player.x + player.w/2, y: player.y - 20, text: 'x' + mult, life: 60 });
}

function spawnParticles(x, y, color, count) {
  for (let i = 0; i < count; i++) {
    particles.push({ x, y, vx: (Math.random() - 0.5) * 8, vy: (Math.random() - 0.5) * 8 - 3, life: 30, color, size: 3 + Math.random() * 4 });
  }
}

function updateParticles() {
  particles = particles.filter(p => {
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.2;
    p.life--;
    return p.life > 0;
  });
}

function drawParticles() {
  particles.forEach(p => {
    ctx.fillStyle = p.color;
    ctx.globalAlpha = p.life / 30;
    ctx.fillRect(p.x - cameraX - p.size/2, p.y - p.size/2, p.size, p.size);
  });
  ctx.globalAlpha = 1;
}

function updateCombo() {
  if (comboTimer > 0) { comboTimer--; if (comboTimer === 0) combo = 0; }
  comboPopups = comboPopups.filter(p => { p.y -= 0.5; p.life--; return p.life > 0; });
}

function activatePowerUp(type) {
  activePowerUp = type;
  powerUpTimer = powerUpDuration;
  screenFlash = 10;
  screenFlashColor = { speed: '#ffff00', shield: '#00ffff', float: '#ff00ff', fire: '#ff6600' }[type];
  addCombo(50);
  if (type === 'shield') player.hasShield = true;
  player.glowColor = { speed: '#ffff00', shield: '#00ffff', float: '#ff00ff', fire: '#ff6600' }[type];
  setTimeout(() => player.glowColor = null, 200);
}

function shootFireball() {
  if (activePowerUp !== 'fire' || powerUpCooldown > 0) return;
  fireballs.push({ x: player.x + (player.facing > 0 ? player.w : -20), y: player.y + player.h/2, vx: player.facing * 10 });
  powerUpCooldown = 25;
}

function formatTime(seconds) {
  const m = Math.floor(seconds / 60);
  const s = Math.floor(seconds % 60);
  return m + ':' + s.toString().padStart(2, '0');
}

function update() {
  if (gameState !== 'playing') return;
  
  gameTime += 1/60;
  
  // Check for level complete
  checkLevelComplete();
  
  // Check for endless mode
  if (gameTime >= 480 && !endlessMode) {
    endlessMode = true;
    score *= 2; // 2x multiplier
  }
  
  // Update power-ups
  if (powerUpTimer > 0) { powerUpTimer--; if (powerUpTimer === 0) { activePowerUp = null; player.glowColor = null; } }
  if (powerUpCooldown > 0) powerUpCooldown--;
  
  // Apply power-up effects
  currentSpeed = SPEED;
  currentGravity = GRAVITY;
  if (activePowerUp === 'speed') currentSpeed = SPEED * 1.8;
  if (activePowerUp === 'float') currentGravity = GRAVITY * 0.35;
  
  animFrame++;
  
  // Player input
  if (keys['ArrowLeft'] || keys['a'] || keys['ArrowRight'] || keys['d']) {
    if (keys['ArrowLeft'] || keys['a']) { player.vx = -currentSpeed; player.facing = -1; }
    else { player.vx = currentSpeed; player.facing = 1; }
  } else {
    player.vx *= 0.85;
  }
  
  player.vy += currentGravity;
  player.x += player.vx;
  player.y += player.vy;
  
  if (player.vx !== 0) player.bobTime += 0.25;
  
  // Bounds
  if (player.x < 0) player.x = 0;
  if (player.x + player.w > worldWidth) player.x = worldWidth - player.w;
  
  // Update moving platforms
  platforms.forEach(p => {
    if (p.moving) {
      if (p.moving.type === 'horizontal') {
        p.x += p.moving.speed * p.moving.dir;
        if (p.x > p.originalX + p.moving.range || p.x < p.originalX - p.moving.range) p.moving.dir *= -1;
      } else if (p.moving.type === 'vertical') {
        p.y += p.moving.speed * p.moving.dir;
        if (p.y > p.originalY + p.moving.range || p.y < p.originalY - p.moving.range) p.moving.dir *= -1;
      }
    }
    
    // Crumbling platforms
    if (p.type === 'crumbling' && p.crumbleTimer > 0) {
      p.crumbleTimer--;
      if (p.crumbleTimer === 0) p.crumbling = true;
    }
  });
  
  // Platform collision
  player.onGround = false;
  platforms.forEach(p => {
    if (p.crumbling) return;
    if (player.x + player.w > p.x && player.x < p.x + p.w && player.y + player.h > p.y && player.y + player.h < p.y + TILE + 15 && player.vy >= 0) {
      if (p.type === 'powerup' && !p.collected) { p.collected = true; activatePowerUp(p.powerType); }
      else if (p.type !== 'finish') {
        player.y = p.y - player.h;
        player.vy = 0;
        player.onGround = true;
        player.jumpsLeft = 2;
        
        // Trigger crumbling
        if (p.type === 'crumbling' && p.crumbleTimer === 0) p.crumbleTimer = 45;
        
        // Move with platform
        if (p.moving) {
          if (p.moving.type === 'horizontal') player.x += p.moving.speed * p.moving.dir;
          else if (p.moving.type === 'vertical') player.y += p.moving.speed * p.moving.dir;
        }
      }
    }
  });
  
  // Fall death
  if (player.y > H + 100) {
    if (player.hasShield) { player.hasShield = false; player.y = 200; player.invincible = 90; }
    else { playerDie(); }
  }
  
  // Enemies
  enemies.forEach(e => {
    if (!e.alive) return;
    e.x += e.vx;
    if (e.x < e.startX - e.range || e.x > e.startX + e.range) e.vx *= -1;
    
    // Follow moving platforms
    if (e.platform && e.platform.moving) {
      if (e.platform.moving.type === 'horizontal') e.x += e.platform.moving.speed * e.platform.moving.dir;
    }
    
    // Collision with player
    if (player.x + player.w > e.x && player.x < e.x + e.w && player.y + player.h > e.y && player.y < e.y + e.h) {
      if (player.vy > 0 && player.y + player.h < e.y + e.h/2 + 10) {
        e.alive = false;
        player.vy = -10;
        addCombo(150);
        spawnParticles(e.x + e.w/2, e.y + e.h/2, '#ff4444', 10);
      } else if (player.invincible <= 0) {
        if (player.hasShield) { player.hasShield = false; player.invincible = 90; }
        else { playerDie(); }
      }
    }
  });
  
  // Fireballs
  fireballs = fireballs.filter(f => {
    f.x += f.vx;
    enemies.forEach(e => { if (!e.alive) return; if (Math.abs(f.x - (e.x + e.w/2)) < 30 && Math.abs(f.y - (e.y + e.h/2)) < 20) { e.alive = false; f.alive = false; addCombo(200); spawnParticles(e.x + e.w/2, e.y + e.h/2, '#ff4444', 10); } });
    return f.x > cameraX && f.x < cameraX + W + 100;
  });
  
  // Coins
  coins.forEach(c => {
    if (!c.collected && player.x + player.w > c.x && player.x < c.x + c.w && player.y + player.h > c.y && player.y < c.y + c.h) {
      c.collected = true;
      bones++;
      addCombo(100);
      spawnParticles(c.x + c.w/2, c.y + c.h/2, '#ffd700', 5);
    }
  });
  
  // Powerups
  powerups.forEach(p => {
    if (!p.collected && player.x + player.w > p.x && player.x < p.x + p.w && player.y + player.h > p.y && player.y < p.y + p.h) {
      p.collected = true;
      const colors = { speed: '#ffff00', shield: '#00ffff', float: '#ff00ff', fire: '#ff6600' };
      spawnParticles(p.x + p.w/2, p.y + p.h/2, colors[p.type], 10);
      activatePowerUp(p.type);
    }
  });
  
  // Camera
  const targetX = player.x - W / 3;
  cameraX += (targetX - cameraX) * 0.1;
  cameraX = Math.max(0, Math.min(worldWidth - W, cameraX));
  
  if (player.invincible > 0) player.invincible--;
  updateCombo();
  updateParticles();
}

function playerDie() {
  lives--;
  screenShake.time = 12;
  if (lives <= 0) {
    gameOver();
  } else {
    player.x = 100;
    player.y = 200;
    player.vx = 0;
    player.vy = 0;
    cameraX = 0;
    player.invincible = 120;
  }
}

function gameOver() {
  gameState = 'gameover';
  if (score > highScore) { highScore = score; localStorage.setItem('doginalHighScore', highScore); newHighScore = true; }
  document.getElementById('finalScore').textContent = score;
  document.getElementById('finalTime').textContent = formatTime(gameTime);
  document.getElementById('finalCoins').textContent = bones;
  document.getElementById('newHighScoreText').style.display = newHighScore ? 'block' : 'none';
  document.getElementById('gameOverScreen').classList.add('active');
}

function showTitleScreen() {
  gameState = 'title';
  document.getElementById('titleScreen').classList.add('active');
  document.getElementById('gameOverScreen').classList.remove('active');
  document.getElementById('levelCompleteScreen').classList.remove('active');
}

function startGame() {
  gameState = 'playing';
  score = 0;
  bones = 0;
  lives = 3;
  gameTime = 0;
  combo = 0;
  activePowerUp = null;
  powerUpTimer = 0;
  endlessMode = false;
  newHighScore = false;
  levelCompleteTriggered = false;
  randomTheme();
  resetPlayer();
  generateWorld();
  document.getElementById('titleScreen').classList.remove('active');
  document.getElementById('gameOverScreen').classList.remove('active');
  document.getElementById('levelCompleteScreen').classList.remove('active');
}

function restartGame() {
  startGame();
}

function continueGame() {
  gameState = 'playing';
  randomTheme();
  generateWorld();
  resetPlayer();
  document.getElementById('levelCompleteScreen').classList.remove('active');
}

function resetPlayer() {
  player.x = 100;
  player.y = 300;
  player.vx = 0;
  player.vy = 0;
  player.onGround = false;
  player.jumpsLeft = 2;
  player.dead = false;
  player.invincible = 60;
  player.hasShield = false;
  cameraX = 0;
  particles = [];
}

function render() {
  ctx.save();
  // Screen shake
  if (screenShake.time > 0) {
    ctx.translate((Math.random() - 0.5) * 8, (Math.random() - 0.5) * 8);
    screenShake.time--;
  }
  
  drawBackground();
  platforms.forEach(p => drawPlatform(p));
  enemies.forEach(e => drawEnemy(e));
  coins.forEach(c => drawCoin(c));
  powerups.forEach(p => drawPowerup(p));
  fireballs.forEach(f => drawFireball(f));
  drawParticles();
  drawPlayer();
  ctx.restore();
  
  drawHUD();
}

function loop() { update(); render(); requestAnimationFrame(loop); }

// Input handling
window.addEventListener('keydown', e => {
  keys[e.code] = true;
  keys[e.key] = true;
  if ((e.code === 'Space' || e.code === 'ArrowUp' || e.key === 'w') && player.jumpsLeft > 0 && gameState === 'playing') {
    player.vy = JUMP_FORCE + (player.jumpsLeft === 1 ? 2 : 0);
    player.jumpsLeft--;
    e.preventDefault();
  }
  if (e.key === 'z' || e.key === 'Z') shootFireball();
});

window.addEventListener('keyup', e => { keys[e.code] = false; keys[e.key] = false; });

// Mobile controls
function setupMobileBtn(id, key, action) {
  const btn = document.getElementById(id);
  btn.addEventListener('touchstart', (e) => { e.preventDefault(); keys[key] = true; if (action) action(); });
  btn.addEventListener('touchend', (e) => { e.preventDefault(); keys[key] = false; });
  btn.addEventListener('mousedown', () => { keys[key] = true; if (action) action(); });
  btn.addEventListener('mouseup', () => { keys[key] = false; });
  btn.addEventListener('mouseleave', () => { keys[key] = false; });
}

setupMobileBtn('btnLeft', 'ArrowLeft');
setupMobileBtn('btnRight', 'ArrowRight');
setupMobileBtn('btnA', 'Space', () => { if (player.jumpsLeft > 0 && gameState === 'playing') { player.vy = JUMP_FORCE + (player.jumpsLeft === 1 ? 2 : 0); player.jumpsLeft--; } });
setupMobileBtn('btnB', 'z', () => shootFireball());

// PFP functions
function openUploadModal() { document.getElementById('upload-modal').classList.add('active'); document.getElementById('validation-msg').className = 'validation-msg'; document.getElementById('validation-msg').textContent = ''; document.getElementById('use-pfp-btn').disabled = true; pendingPfp = null; }
function closeUploadModal() { document.getElementById('upload-modal').classList.remove('active'); document.getElementById('pfp-input').value = ''; }

const dropZone = document.getElementById('drop-zone');
const pfpInput = document.getElementById('pfp-input');
dropZone.addEventListener('click', () => pfpInput.click());
pfpInput.addEventListener('change', e => { const file = e.target.files[0]; if (file) handlePfpFile(file); });

function handlePfpFile(file) {
  const reader = new FileReader();
  reader.onload = function(ev) {
    const img = new Image();
    img.onload = function() {
      const ext = file.name.split('.').pop().toLowerCase();
      let valid = ['png','jpg','jpeg','webp'].includes(ext);
      let isTest = file.name.toLowerCase().includes(TEST_PFP_HASH);
      const msgEl = document.getElementById('validation-msg');
      const btn = document.getElementById('use-pfp-btn');
      if (valid) { msgEl.textContent = isTest ? '‚úÖ Test PFP!' : '‚úÖ Ready!'; msgEl.className = 'validation-msg success'; btn.disabled = false; pendingPfp = { file, img }; }
      else { msgEl.textContent = '‚ùå Use PNG, JPG, or WEBP'; msgEl.className = 'validation-msg error'; btn.disabled = true; pendingPfp = null; }
    };
    img.src = ev.target.result;
  };
  reader.readAsDataURL(file);
}

function applyPfp() {
  if (!pendingPfp) return;
  playerImg = pendingPfp.img;
  closeUploadModal();
}

// Initialize
document.getElementById('titleHighScore').textContent = highScore;
randomTheme();
loop();

</script>
</body>
</html>
