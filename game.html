<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>üêï Doginal Dash</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Outfit:wght@400;600;800&display=swap');
    :root { --primary: #f5c842; --bg-dark: #0a0a1a; }
    * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    html, body { overflow: hidden; touch-action: none; background: var(--bg-dark); }
    .gameboy-container { display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh; background: #0a0a1a; padding: 10px; }
    .gameboy { background: linear-gradient(145deg, #1a1a2e 0%, #0f0f1a 100%); border-radius: 20px 20px 80px 80px; padding: 25px 40px 60px; box-shadow: 0 0 0 4px #2a2a4a, 0 0 0 8px #1a1a2e, 0 15px 50px rgba(0,0,0,0.8); max-width: 95vw; max-height: 95vh; }
    .gameboy-screen-frame { background: #111; border-radius: 8px 8px 20px 20px; padding: 12px; }
    .gameboy-screen-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
    .gameboy-brand { font-family: 'Press Start 2P', monospace; font-size: 0.4rem; color: #666; letter-spacing: 2px; }
    .power-led { width: 6px; height: 6px; background: #4ade80; border-radius: 50%; box-shadow: 0 0 6px #4ade80; }
    #gameCanvas { display: block; width: 100%; max-width: 400px; aspect-ratio: 5/3; image-rendering: pixelated; border-radius: 4px; background: #1a1a2e; }
    .gameboy-controls { display: flex; justify-content: space-between; align-items: center; margin-top: 20px; padding: 0 10px; }
    .dpad { position: relative; width: 90px; height: 90px; }
    .dpad-btn { position: absolute; background: #222; border: none; cursor: pointer; }
    .dpad-up, .dpad-down { width: 28px; height: 30px; left: 50%; transform: translateX(-50%); }
    .dpad-up { top: 0; border-radius: 6px 6px 0 0; }
    .dpad-down { bottom: 0; border-radius: 0 0 6px 6px; }
    .dpad-left, .dpad-right { width: 30px; height: 28px; top: 50%; transform: translateY(-50%); }
    .dpad-left { left: 0; border-radius: 6px 0 0 6px; }
    .dpad-right { right: 0; border-radius: 0 6px 6px 0; }
    .dpad-center { width: 28px; height: 28px; left: 50%; top: 50%; transform: translate(-50%, -50%); background: #222; border-radius: 3px; }
    .action-btns { display: flex; gap: 15px; transform: rotate(-25deg); }
    .action-btn { width: 45px; height: 45px; border-radius: 50%; border: none; font-family: 'Press Start 2P', monospace; font-size: 0.6rem; cursor: pointer; box-shadow: 0 4px 0 rgba(0,0,0,0.5); }
    .btn-b, .btn-a { background: #8b2252; color: #fff; }
    .btn-b:active, .btn-a:active { transform: translateY(4px); box-shadow: none; }
    .start-select { display: flex; gap: 20px; margin-top: 15px; justify-content: center; }
    .small-btn { background: #333; border: none; padding: 8px 20px; border-radius: 10px; color: #666; font-size: 0.45rem; font-family: 'Press Start 2P', monospace; cursor: pointer; transform: rotate(-25deg); box-shadow: 0 2px 0 #111; }
    .small-btn:active { transform: rotate(-25deg) translateY(2px); box-shadow: none; }
    .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.9); display: none; align-items: center; justify-content: center; z-index: 1000; }
    .modal-overlay.active { display: flex; }
    .modal { background: #12122a; border-radius: 12px; padding: 1.5rem; max-width: 90vw; width: 300px; border: 2px solid var(--primary); position: relative; }
    .modal h2 { font-family: 'Press Start 2P', monospace; font-size: 0.7rem; color: var(--primary); margin-bottom: 1rem; text-align: center; }
    .drop-zone { border: 2px dashed #444; border-radius: 8px; padding: 1.5rem; text-align: center; cursor: pointer; }
    .drop-zone-text { color: #aaa; font-size: 0.85rem; }
    #pfp-input { display: none; }
    .validation-msg { margin-top: 1rem; padding: 0.5rem; border-radius: 6px; font-size: 0.75rem; display: none; }
    .validation-msg.success { display: block; background: rgba(74, 222, 128, 0.1); border: 1px solid #4ade80; color: #4ade80; }
    .validation-msg.error { display: block; background: rgba(248, 113, 113, 0.1); border: 1px solid #f87171; color: #f87171; }
    .btn-primary { background: var(--primary); color: #000; font-weight: 600; padding: 0.6rem 1.5rem; border: none; border-radius: 6px; cursor: pointer; font-size: 0.9rem; margin-top: 1rem; width: 100%; }
    .btn-primary:disabled { opacity: 0.5; }
    .close-modal { position: absolute; top: 10px; right: 10px; background: none; border: none; color: #666; font-size: 1.2rem; cursor: pointer; }
  </style>
</head>
<body>
  <div class="gameboy-container">
    <div class="gameboy">
      <div class="gameboy-screen-frame">
        <div class="gameboy-screen-header">
          <span class="gameboy-brand">DOGINAL</span>
          <div class="power-led"></div>
        </div>
        <canvas id="gameCanvas" width="800" height="480"></canvas>
      </div>
      <div class="gameboy-controls">
        <div class="dpad">
          <button class="dpad-btn dpad-up" data-key="ArrowUp"></button>
          <button class="dpad-btn dpad-down" data-key="ArrowDown"></button>
          <button class="dpad-btn dpad-left" data-key="ArrowLeft"></button>
          <button class="dpad-btn dpad-right" data-key="ArrowRight"></button>
          <div class="dpad-center"></div>
        </div>
        <div class="action-btns">
          <button class="action-btn btn-b" data-key="b">B</button>
          <button class="action-btn btn-a" data-key="a">A</button>
        </div>
      </div>
      <div class="start-select">
        <button class="small-btn" data-key="Select">SELECT</button>
        <button class="small-btn" onclick="handleStart()">START</button>
      </div>
    </div>
  </div>

  <div class="modal-overlay" id="upload-modal">
    <div class="modal">
      <button class="close-modal" onclick="closeUploadModal()">x</button>
      <h2>üêï UPLOAD PFP</h2>
      <div class="drop-zone" id="drop-zone"><div class="drop-zone-text">Tap to choose image</div></div>
      <input type="file" id="pfp-input" accept="image/*">
      <div class="validation-msg" id="validation-msg"></div>
      <button class="btn-primary" id="use-pfp-btn" disabled onclick="applyPfp()">PLAY</button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;

    let playerImg = null, gameRunning = false, score = 0, coins = 0, lives = 3;
    let keys = {}, animFrame = 0, cameraX = 0;
    let currentLevel = 1, levelComplete = false;
    let combo = 0, comboTimer = 0, comboPopups = [];
    let activePowerUp = null, powerUpTimer = 0, powerUpCooldown = 0;
    let enemies = [], fireballs = [];
    let currentTheme = 0, themeTransition = 0;
    let highScore = parseInt(localStorage.getItem('doginalHighScore')) || 0;
    let newHighScore = false, screenFlash = 0;

    const player = { x: 100, y: 300, w: 48, h: 48, vx: 0, vy: 0, onGround: false, jumpsLeft: 2, facing: 1, bobTime: 0, dead: false, invincible: 0, hasShield: false };
    const TILE = 48;

    const THEMES = ['vegas', 'miami', 'nyc'];
    const themeData = {
      vegas: { skyTop: '#1a0a2e', skyMid: '#2d1b4e', skyBot: '#4a1a5e', ground: '#5a1a1a', groundPattern: '#8b0000', platform: '#8b2252', platformTop: '#ff69b4', accent: '#ff00ff', coin: '#ffd700' },
      miami: { skyTop: '#ff69b4', skyMid: '#ff8c42', skyBot: '#ffc0cb', ground: '#ffb6c1', groundPattern: '#ffffff', platform: '#00ced1', platformTop: '#7fffd4', accent: '#00ff00', coin: '#ff6b6b' },
      nyc: { skyTop: '#0a0a2e', skyMid: '#1a1a3e', skyBot: '#2a2a4e', ground: '#4a4a5a', groundPattern: '#ffd700', platform: '#ffd700', platformTop: '#ffff00', accent: '#ffff00', coin: '#ffd700' }
    };

    function getTheme() { return themeData[THEMES[currentTheme]]; }
    function randomTheme() { themeTransition = 60; currentTheme = Math.floor(Math.random() * THEMES.length); }
    function getLevelLength(level) { return 40 + (level - 1) * 20; }
    function getFinishX(level) { return (getLevelLength(level) - 5) * TILE; }

    let platforms = [], coinList = [];

    function makePlatforms() {
      const len = getLevelLength(currentLevel);
      platforms = [
        ...Array.from({length: len}, (_, i) => ({ x: i*TILE, y: H - TILE, w: TILE, h: TILE, type:'ground' })),
        { x: 4*TILE, y: H - 3*TILE, w: 3*TILE, h: TILE, type:'platform' },
        { x: 9*TILE, y: H - 4*TILE, w: 3*TILE, h: TILE, type:'platform' },
        { x: 14*TILE, y: H - 3*TILE, w: 4*TILE, h: TILE, type:'platform' },
        { x: 19*TILE, y: H - 5*TILE, w: 3*TILE, h: TILE, type:'platform' },
        { x: 24*TILE, y: H - 3*TILE, w: 3*TILE, h: TILE, type:'platform' },
        { x: 28*TILE, y: H - 4*TILE, w: 2*TILE, h: TILE, type:'platform' },
        { x: 32*TILE, y: H - 6*TILE, w: 4*TILE, h: TILE, type:'platform' },
        { x: 36*TILE, y: H - 3*TILE, w: 3*TILE, h: TILE, type:'platform' },
      ];
      
      if (currentLevel >= 2) { platforms.push({ x: 42*TILE, y: H - 5*TILE, w: 3*TILE, h: TILE, type:'platform' }); platforms.push({ x: 48*TILE, y: H - 4*TILE, w: 4*TILE, h: TILE, type:'platform' }); }
      if (currentLevel >= 3) { platforms.push({ x: 55*TILE, y: H - 6*TILE, w: 3*TILE, h: TILE, type:'platform' }); platforms.push({ x: 60*TILE, y: H - 3*TILE, w: 5*TILE, h: TILE, type:'platform' }); }
      if (currentLevel >= 4) { platforms.push({ x: 68*TILE, y: H - 5*TILE, w: 4*TILE, h: TILE, type:'platform' }); platforms.push({ x: 75*TILE, y: H - 7*TILE, w: 3*TILE, h: TILE, type:'platform' }); platforms.push({ x: 80*TILE, y: H - 4*TILE, w: 4*TILE, h: TILE, type:'platform' }); }
      
      const powerUpTypes = ['speed', 'shield', 'float', 'fire'];
      let powerUpCount = 0;
      platforms.forEach((p, i) => {
        if (p.type === 'platform' && i > 0 && i % 3 === 0 && powerUpCount < 3) {
          platforms.push({ x: p.x + TILE, y: p.y - TILE, w: 32, h: 32, type: 'powerup', powerType: powerUpTypes[powerUpCount % 4] });
          powerUpCount++;
        }
      });
      
      enemies = [];
      if (currentLevel >= 2) {
        [8, 16, 24, 32, 40].forEach(x => {
          if (x * TILE < getFinishX(currentLevel) - 200) {
            enemies.push({ x: x * TILE, y: H - 2 * TILE, w: 40, h: 32, vx: 1 + currentLevel * 0.3, startX: x * TILE, range: 150, alive: true });
          }
        });
      }
      
      platforms.push({ x: getFinishX(currentLevel), y: H - 3*TILE, w: 4*TILE, h: TILE, type:'finish' });
      
      const gaps = [17, 18, 26, 27, ...(currentLevel >= 2 ? [35, 36, 44, 45] : []), ...(currentLevel >= 3 ? [55, 56, 65, 66] : []), ...(currentLevel >= 4 ? [72, 73, 82, 83] : [])];
      platforms = platforms.filter(p => { if (p.type !== 'ground') return true; return !gaps.includes(p.x / TILE); });
    }

    function makeCoins() {
      coinList = [];
      platforms.filter(p => p.type === 'platform').forEach(p => { if (Math.random() > 0.3) coinList.push({ x: p.x + TILE + 12, y: p.y - 40, w: 24, h: 24, collected: false }); });
    }

    function drawBackground() {
      const t = getTheme();
      const grad = ctx.createLinearGradient(0, 0, 0, H);
      if (themeTransition > 0) { const prevT = themeData[THEMES[(currentTheme + 2) % 3]]; grad.addColorStop(0, themeTransition > 30 ? prevT.skyTop : t.skyTop); grad.addColorStop(0.6, themeTransition > 30 ? prevT.skyMid : t.skyMid); grad.addColorStop(1, themeTransition > 30 ? prevT.skyBot : t.skyBot); themeTransition--; }
      else { grad.addColorStop(0, t.skyTop); grad.addColorStop(0.6, t.skyMid); grad.addColorStop(1, t.skyBot); }
      ctx.fillStyle = grad; ctx.fillRect(0, 0, W, H);
      ctx.fillStyle = t.groundPattern; ctx.globalAlpha = 0.3;
      for (let i = 0; i < 15; i++) { const bx = ((i * 120 - cameraX * 0.1) % (W + 200)) - 100; const bh = 80 + (i * 37) % 100; ctx.fillRect(bx, H - TILE - bh, 60, bh); }
      ctx.fillStyle = t.platform; ctx.globalAlpha = 0.5;
      for (let i = 0; i < 12; i++) { const bx = ((i * 150 - cameraX * 0.3) % (W + 200)) - 100; const bh = 60 + (i * 53) % 80; ctx.fillRect(bx, H - TILE - bh, 50, bh); }
      ctx.globalAlpha = 1;
      ctx.fillStyle = '#ffffff88';
      for (let i = 0; i < 30; i++) { const sx = ((i * 73 + 200) % (W * 2) - cameraX * 0.2) % W; const sy = (i * 37 + 50) % (H * 0.6); ctx.fillRect(sx, sy, 2, 2); }
    }

    function drawTile(x, y, type, w) {
      const t = getTheme();
      if (type === 'finish') {
        ctx.fillStyle = '#fff'; ctx.fillRect(x, y, w, TILE);
        for (let row = 0; row < TILE / 12; row++) { for (let col = 0; col < w / 12; col++) { ctx.fillStyle = (row + col) % 2 === 0 ? '#000' : '#fff'; ctx.fillRect(x + col * 12, y + row * 12, 12, 12); } }
        ctx.fillStyle = '#888'; ctx.fillRect(x + w - 20, y - 80, 6, 80);
        ctx.fillStyle = '#f00'; ctx.beginPath(); ctx.moveTo(x + w - 14, y - 80); ctx.lineTo(x + w + 30, y - 65); ctx.lineTo(x + w - 14, y - 50); ctx.fill();
      } else if (type === 'ground') {
        ctx.fillStyle = t.ground; ctx.fillRect(x, y, TILE, TILE);
        ctx.fillStyle = t.platformTop; ctx.fillRect(x, y, TILE, 8);
      } else if (type === 'powerup') {
        const colors = { speed: '#ffff00', shield: '#00ffff', float: '#ff00ff', fire: '#ff6600' };
        ctx.shadowBlur = 15; ctx.shadowColor = colors[player.w] || '#fff';
        ctx.fillStyle = colors[player.w] || '#fff'; ctx.beginPath(); ctx.arc(x + 16, y + 16, 14, 0, Math.PI * 2); ctx.fill();
        ctx.shadowBlur = 0;
      } else {
        ctx.fillStyle = t.platform; ctx.fillRect(x, y, w||TILE, TILE);
        ctx.fillStyle = t.platformTop; ctx.fillRect(x, y, w||TILE, 6);
      }
    }

    function drawEnemy(e) {
      if (!e.alive) return;
      const drawX = e.x - cameraX;
      ctx.fillStyle = '#666'; ctx.fillRect(drawX, e.y, e.w, e.h);
      ctx.fillStyle = '#ffb6c1'; ctx.fillRect(drawX + 4, e.y - 8, 8, 8); ctx.fillRect(drawX + e.w - 12, e.y - 8, 8, 8);
      ctx.fillStyle = '#ffff00'; ctx.fillRect(drawX + 8, e.y + 8, 8, 8); ctx.fillRect(drawX + e.w - 16, e.y + 8, 8, 8);
    }

    function drawFireball(f) {
      ctx.fillStyle = '#ff6600'; ctx.beginPath(); ctx.arc(f.x - cameraX, f.y, 8, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#ffff00'; ctx.beginPath(); ctx.arc(f.x - cameraX, f.y, 5, 0, Math.PI * 2); ctx.fill();
    }

    function drawDefaultDog(x, y, w, h, facing, bobOffset) {
      const scale = w / 16;
      const px = (col, row, color) => { ctx.fillStyle = color; ctx.fillRect(x + col * scale, y + row * scale + bobOffset, scale, scale); };
      const B = '#8B5E3C', D = '#5C3A1E', Wc = '#F5E6D0', N = '#1a0a00', T = '#e07050', _ = null;
      const grid = [
        [_,_,_,D,D,D,D,D,D,D,D,_,_,_,_,_],[_,_,D,B,B,B,B,B,B,B,D,D,_,_,_,_],[_,D,B,B,Wc,B,B,Wc,B,B,B,B,D,_,_,_],[_,D,B,B,N,B,B,N,B,B,B,B,D,_,_,_],[_,D,B,B,B,B,B,B,B,B,B,B,D,_,_,_],[_,D,D,B,B,B,T,B,B,B,D,D,_,_,_,_],[_,_,D,B,B,B,B,B,B,B,D,_,_,_,_,_],[_,_,D,B,B,B,B,B,B,B,B,D,_,_,_,_],[D,D,D,B,B,B,B,B,B,B,B,B,D,_,_,_],[B,B,B,B,B,B,B,B,B,B,B,B,B,D,_,_],[B,B,B,B,B,B,B,B,B,B,B,B,B,B,D,_],[D,B,B,B,B,B,B,B,B,B,B,B,B,D,_,_],[_,D,D,B,B,D,D,B,B,D,B,B,D,_,_,_],[_,_,_,D,D,_,_,D,D,_,D,D,_,_,_,_],[_,_,_,D,D,_,_,D,D,_,D,D,_,_,_,_],[_,_,_,D,_,_,_,D,_,_,D,_,_,_,_,_],
      ];
      grid.forEach((row, ry) => row.forEach((c, cx2) => { if (!c) return; const dx = facing > 0 ? cx2 : 15 - cx2; px(dx, ry, c); }));
    }

    function drawCoin(x, y, w, h) {
      const t = getTheme(); const s = w / 8;
      for (let row = 1; row <= 6; row++) { for (let col = 1; col <= 6; col++) { const dist = Math.sqrt((col-3.5)**2 + (row-3.5)**2); if (dist < 3.2) { ctx.fillStyle = (col + row) % 2 === 0 ? t.coin : '#ffe888'; ctx.fillRect(x + col*s, y + row*s, s, s); } } }
    }

    function drawPlayer() {
      if (player.dead) return;
      const drawX = player.x - cameraX, bob = Math.sin(player.bobTime) * 1.5;
      if (player.invincible > 0 && Math.floor(player.invincible / 4) % 2 === 0) return;
      if (player.hasShield) { ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(drawX + player.w/2, player.y + player.h/2 + bob, player.w * 0.7, 0, Math.PI * 2); ctx.stroke(); }
      if (activePowerUp === 'fire') { ctx.fillStyle = '#ff6600'; ctx.beginPath(); ctx.arc(drawX + player.w + 5, player.y + player.h/2 + bob, 8 + Math.sin(animFrame * 0.3) * 3, 0, Math.PI * 2); ctx.fill(); }
      if (playerImg) { ctx.save(); ctx.imageSmoothingEnabled = false; if (player.facing < 0) { ctx.translate(drawX + player.w, player.y + bob); ctx.scale(-1, 1); ctx.drawImage(playerImg, 0, 0, player.w, player.h); } else { ctx.drawImage(playerImg, drawX, player.y + bob, player.w, player.h); } ctx.restore(); }
      else { drawDefaultDog(drawX, player.y, player.w, player.h, player.facing, bob); }
      if (!player.onGround) { ctx.fillStyle = 'rgba(0,0,0,0.3)'; ctx.fillRect(drawX + 6, H - TILE - 4, player.w - 12, 6); }
      if (powerUpTimer > 0) { const colors = { speed: '#ffff00', shield: '#00ffff', float: '#ff00ff', fire: '#ff6600' }; ctx.fillStyle = '#333'; ctx.fillRect(drawX, player.y - 15, player.w, 6); ctx.fillStyle = colors[activePowerUp]; ctx.fillRect(drawX, player.y - 15, player.w * (powerUpTimer / 360), 6); }
    }

    function drawHUD() {
      const t = getTheme();
      ctx.fillStyle = t.accent; ctx.font = '12px "Press Start 2P", monospace'; ctx.textAlign = 'left'; ctx.fillText(score, 10, 25);
      if (combo > 1) { ctx.fillStyle = '#ff6600'; ctx.font = 'bold 16px "Press Start 2P", monospace'; ctx.fillText('x' + combo + ' üî•', 10, 50); }
      ctx.fillStyle = t.accent; ctx.font = '10px "Press Start 2P", monospace'; ctx.textAlign = 'right'; ctx.fillText('LV' + currentLevel, W - 10, 25);
      ctx.fillText('‚ù§Ô∏è'.repeat(Math.min(lives, 5)), W - 10, 45);
      ctx.fillStyle = '#888'; ctx.font = '8px "Press Start 2P", monospace'; ctx.textAlign = 'center'; ctx.fillText('üèÜ' + highScore, W/2, 20);
      comboPopups.forEach(p => { ctx.fillStyle = 'rgba(255, 200, 0, ' + (p.life / 30) + ')'; ctx.font = 'bold 16px "Press Start 2P", monospace'; ctx.textAlign = 'center'; ctx.fillText(p.text, p.x - cameraX, p.y); });
      if (screenFlash > 0) { ctx.fillStyle = 'rgba(255,255,255,' + (screenFlash / 20) + ')'; ctx.fillRect(0, 0, W, H); screenFlash--; }
    }

    function addCombo(points) {
      combo++; comboTimer = 120; const mult = Math.min(combo, 10); score += points * mult;
      comboPopups.push({ x: player.x + player.w/2, y: player.y - 20, text: 'x' + mult + ' ' + (points * mult) + '!', life: 60 });
    }
    function updateCombo() { if (comboTimer > 0) { comboTimer--; if (comboTimer === 0) combo = 0; } comboPopups = comboPopups.filter(p => { p.y -= 0.5; p.life--; return p.life > 0; }); }
    
    function activatePowerUp(type) { activePowerUp = type; powerUpTimer = 360; screenFlash = 15; addCombo(50); if (type === 'shield') player.hasShield = true; }
    
    function shootFireball() {
      if (activePowerUp !== 'fire' || powerUpCooldown > 0) return;
      fireballs.push({ x: player.x + (player.facing > 0 ? player.w : -20), y: player.y + player.h/2, vx: player.facing * 8, alive: true });
      powerUpCooldown = 30;
      enemies.forEach(e => { if (!e.alive) return; const dx = fireballs[fireballs.length-1].x - (e.x + e.w/2), dy = fireballs[fireballs.length-1].y - (e.y + e.h/2); if (Math.abs(dx) < 40 && Math.abs(dy) < 30) { e.alive = false; addCombo(200); } });
    }

    const GRAVITY = 0.6, JUMP_FORCE = -13, SPEED = 4;

    function update() {
      if (!gameRunning || levelComplete) return;
      
      worldWidth = getLevelLength(currentLevel) * TILE;
      const finishX = getFinishX(currentLevel);
      
      if (powerUpTimer > 0) { powerUpTimer--; if (powerUpTimer === 0 && activePowerUp !== 'shield') activePowerUp = null; }
      if (powerUpCooldown > 0) powerUpCooldown--;
      
      let currentSpeed = SPEED;
      let currentGravity = GRAVITY;
      if (activePowerUp === 'speed') currentSpeed = SPEED * 1.7;
      if (activePowerUp === 'float') currentGravity = GRAVITY * 0.35;
      
      animFrame++;
      if (keys['ArrowLeft'] || keys['a']) { player.vx = -currentSpeed; player.facing = -1; }
      else if (keys['ArrowRight'] || keys['d']) { player.vx = currentSpeed; player.facing = 1; }
      else player.vx *= 0.85;
      
      player.vy += currentGravity;
      player.x += player.vx;
      player.y += player.vy;
      if (player.vx !== 0) player.bobTime += 0.2;
      if (player.x < 0) player.x = 0;
      if (player.x + player.w > worldWidth) player.x = worldWidth - player.w;
      
      if (player.x + player.w > finishX && player.x < finishX + 4 * TILE && player.y + player.h > H - 3 * TILE - 80) { completeLevel(); return; }
      
      player.onGround = false;
      platforms.forEach(p => {
        if (player.x + player.w > p.x && player.x < p.x + p.w && player.y + player.h > p.y && player.y + player.h < p.y + TILE + 12 && player.vy >= 0) {
          if (p.type === 'powerup' && !p.collected) { p.collected = true; activatePowerUp(p.powerType); }
          else if (p.type !== 'finish') { player.y = p.y - player.h; player.vy = 0; player.onGround = true; player.jumpsLeft = 2; }
        }
      });
      
      if (player.y > H + 100) {
        if (player.hasShield) { player.hasShield = false; player.y = 200; player.invincible = 60; }
        else { lives--; if (lives <= 0) { gameOver(); return; } player.x = 100; player.y = 200; player.vx = 0; player.vy = 0; cameraX = 0; player.invincible = 120; }
      }
      
      enemies.forEach(e => {
        if (!e.alive) return;
        e.x += e.vx;
        if (e.x < e.startX - e.range || e.x > e.startX + e.range) e.vx *= -1;
        
        if (player.x + player.w > e.x && player.x < e.x + e.w && player.y + player.h > e.y && player.y < e.y + e.h) {
          if (player.vy > 0 && player.y + player.h < e.y + e.h / 2) { e.alive = false; player.vy = -10; addCombo(150); }
          else if (player.invincible <= 0) { if (player.hasShield) { player.hasShield = false; player.invincible = 60; } else { lives--; if (lives <= 0) { gameOver(); return; } player.x = 100; player.y = 200; player.vx = 0; player.vy = 0; cameraX = 0; player.invincible = 120; } }
        }
      });
      
      fireballs = fireballs.filter(f => { f.x += f.vx; enemies.forEach(e => { if (!e.alive) return; const dx = f.x - (e.x + e.w/2), dy = f.y - (e.y + e.h/2); if (Math.abs(dx) < 40 && Math.abs(dy) < 30) { e.alive = false; f.alive = false; addCombo(200); } }); return f.alive && f.x > cameraX && f.x < cameraX + W + 100; });
      
      coinList.forEach(c => { if (!c.collected && player.x + player.w > c.x && player.x < c.x + c.w && player.y + player.h > c.y && player.y < c.y + c.h) { c.collected = true; coins++; addCombo(100); } });
      
      cameraX += (player.x - W / 3 - cameraX) * 0.12;
      cameraX = Math.max(0, Math.min(worldWidth - W, cameraX));
      if (player.invincible > 0) player.invincible--;
      updateCombo();
    }

    function gameOver() {
      gameRunning = false;

      if (score > highScore) { highScore = score; localStorage.setItem('doginalHighScore', highScore); newHighScore = true; }
      ctx.fillStyle = 'rgba(0,0,0,0.8)';
      ctx.fillRect(0, 0, W, H);
      ctx.fillStyle = '#f00';
      ctx.font = '1.2rem "Press Start 2P", monospace';
      ctx.textAlign = 'center';
      ctx.fillText('GAME OVER', W/2, H/2 - 40);
      if (newHighScore) { ctx.fillStyle = '#ffd700'; ctx.fillText('üèÜ NEW HIGH SCORE!', W/2, H/2 - 10); }
      ctx.fillStyle = '#fff';
      ctx.font = '0.5rem "Press Start 2P", monospace';
      ctx.fillText('Score: ' + score, W/2, H/2 + 20);
      ctx.fillText('Level: ' + currentLevel, W/2, H/2 + 40);
      ctx.fillText('Tap START to restart', W/2, H/2 + 70);
    }

    function completeLevel() {
      levelComplete = true;
      gameRunning = false;
      score += 1000 * currentLevel;
    }
    
    function showLevelComplete() {
      ctx.fillStyle = 'rgba(0,0,0,0.8)';
      ctx.fillRect(0, 0, W, H);
      ctx.fillStyle = '#4ade80';
      ctx.font = '1rem "Press Start 2P", monospace';
      ctx.textAlign = 'center';
      ctx.fillText('LEVEL ' + currentLevel + ' COMPLETE!', W/2, H/2 - 30);
      ctx.fillStyle = '#fff';
      ctx.font = '0.5rem "Press Start 2P", monospace';
      ctx.fillText('Score: ' + score, W/2, H/2 + 10);
      ctx.fillText('Tap START for Level ' + (currentLevel + 1), W/2, H/2 + 40);
    }

    function nextLevel() { currentLevel++; restartGame(); }
    function restartGame() { 
      currentLevel = 1; score = 0; coins = 0; lives = 3; combo = 0; activePowerUp = null; powerUpTimer = 0; 
      randomTheme();
      resetGame(); 
    }
    function resetGame() {
      levelComplete = false;
      player.x = 100; player.y = 300; player.vx = 0; player.vy = 0;
      player.onGround = false; player.jumpsLeft = 2; player.dead = false; player.invincible = 0; player.hasShield = false;
      cameraX = 0;
      makePlatforms();
      makeCoins();
      gameRunning = true;
    }

    function render() {
      ctx.clearRect(0, 0, W, H);
      drawBackground();
      ctx.save();
      platforms.forEach(p => drawTile(p.x - cameraX, p.y, p.type, p.w));
      enemies.forEach(e => drawEnemy(e));
      fireballs.forEach(f => drawFireball(f));
      coinList.forEach(c => { if (!c.collected) { const float = Math.sin(animFrame * 0.08 + c.x * 0.1) * 3; drawCoin(c.x - cameraX, c.y + float, c.w, c.h); } });
      drawPlayer();
      ctx.restore();
      drawHUD();
      if (levelComplete) showLevelComplete();
    }

    function loop() { update(); render(); requestAnimationFrame(loop); }

    window.addEventListener('keydown', e => {
      keys[e.code] = true; keys[e.key] = true;
      if ((e.code === 'Space' || e.code === 'ArrowUp' || e.key === 'w') && player.jumpsLeft > 0 && gameRunning) { player.vy = JUMP_FORCE + (player.jumpsLeft === 1 ? 1.5 : 0); player.jumpsLeft--; e.preventDefault(); }
      if (e.key === 'z' || e.key === 'Z') shootFireball();
    });
    window.addEventListener('keyup', e => { keys[e.code] = false; keys[e.key] = false; });

    document.querySelectorAll('[data-key]').forEach(btn => {
      const key = btn.dataset.key;
      const handle = (pressed) => {
        if (key === 'a' || key === 'b') { if (pressed && player.jumpsLeft > 0 && gameRunning) { player.vy = JUMP_FORCE + (player.jumpsLeft === 1 ? 1.5 : 0); player.jumpsLeft--; } if (key === 'b' && pressed) shootFireball(); return; }
        if (key === 'Select') { openUploadModal(); return; }
        keys[key] = pressed;
        if (key === 'ArrowLeft') keys['a'] = pressed;
        if (key === 'ArrowRight') keys['d'] = pressed;
      };
      btn.addEventListener('touchstart', (e) => { e.preventDefault(); handle(true); });
      btn.addEventListener('touchend', (e) => { e.preventDefault(); handle(false); });
      btn.addEventListener('mousedown', () => handle(true));
      btn.addEventListener('mouseup', () => handle(false));
    });

    let pendingPfp = null;
    const TEST_PFP_HASH = '3772';
    
    function validateDoginalPfp(file, img) {
      const ext = file.name.split('.').pop().toLowerCase();
      if (!['png','jpg','jpeg','webp'].includes(ext)) return { valid: false, message: 'Use PNG, JPG, or WEBP' };
      if (file.name.toLowerCase().includes(TEST_PFP_HASH)) return { valid: true, message: '‚úÖ Test PFP!', isTest: true };
      return { valid: true, message: '‚úÖ Ready!', isTest: false };
    }
    
    function openUploadModal() { document.getElementById('upload-modal').classList.add('active'); document.getElementById('validation-msg').className = 'validation-msg'; document.getElementById('validation-msg').textContent = ''; document.getElementById('use-pfp-btn').disabled = true; pendingPfp = null; }
    function closeUploadModal() { document.getElementById('upload-modal').classList.remove('active'); document.getElementById('pfp-input').value = ''; }
    
    const dropZone = document.getElementById('drop-zone');
    const pfpInput = document.getElementById('pfp-input');
    dropZone.addEventListener('click', () => pfpInput.click());
    pfpInput.addEventListener('change', e => { const file = e.target.files[0]; if (file) handlePfpFile(file); });
    
    function handlePfpFile(file) {
      const reader = new FileReader();
      reader.onload = function(ev) {
        const img = new Image();
        img.onload = function() {
          const result = validateDoginalPfp(file, img);
          const msgEl = document.getElementById('validation-msg');
          const btn = document.getElementById('use-pfp-btn');
          if (result.valid) { msgEl.textContent = result.message; msgEl.className = 'validation-msg success'; btn.disabled = false; pendingPfp = { file, img, result }; }
          else { msgEl.textContent = '‚ùå ' + result.message; msgEl.className = 'validation-msg error'; btn.disabled = true; pendingPfp = null; }
        };
        img.src = ev.target.result;
      };
      reader.readAsDataURL(file);
    }
    
    function applyPfp() {
      if (!pendingPfp) return;
      playerImg = pendingPfp.img;
      closeUploadModal();
      restartGame();
    }
    
    function handleStart() {
      if (!gameRunning && !levelComplete) restartGame();
      else if (levelComplete) nextLevel();
      else if (!gameRunning) resetGame();
    }

    randomTheme();
    document.addEventListener('DOMContentLoaded', function() { restartGame(); loop(); });
  </script>
</body>
</html>
